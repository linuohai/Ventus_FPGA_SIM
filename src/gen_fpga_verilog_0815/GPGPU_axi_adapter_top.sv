// Generated by CIRCT firtool-1.62.0
// Standard header to adapt well known macros for register randomization.
`ifndef RANDOMIZE
  `ifdef RANDOMIZE_MEM_INIT
    `define RANDOMIZE
  `endif // RANDOMIZE_MEM_INIT
`endif // not def RANDOMIZE
`ifndef RANDOMIZE
  `ifdef RANDOMIZE_REG_INIT
    `define RANDOMIZE
  `endif // RANDOMIZE_REG_INIT
`endif // not def RANDOMIZE

// RANDOM may be set to an expression that produces a 32-bit random unsigned value.
`ifndef RANDOM
  `define RANDOM $random
`endif // not def RANDOM

// Users can define INIT_RANDOM as general code that gets injected into the
// initializer block for modules with registers.
`ifndef INIT_RANDOM
  `define INIT_RANDOM
`endif // not def INIT_RANDOM

// If using random initialization, you can also define RANDOMIZE_DELAY to
// customize the delay used, otherwise 0.002 is used.
`ifndef RANDOMIZE_DELAY
  `define RANDOMIZE_DELAY 0.002
`endif // not def RANDOMIZE_DELAY

// Define INIT_RANDOM_PROLOG_ for use in our modules below.
`ifndef INIT_RANDOM_PROLOG_
  `ifdef RANDOMIZE
    `ifdef VERILATOR
      `define INIT_RANDOM_PROLOG_ `INIT_RANDOM
    `else  // VERILATOR
      `define INIT_RANDOM_PROLOG_ `INIT_RANDOM #`RANDOMIZE_DELAY begin end
    `endif // VERILATOR
  `else  // RANDOMIZE
    `define INIT_RANDOM_PROLOG_
  `endif // RANDOMIZE
`endif // not def INIT_RANDOM_PROLOG_

// Include register initializers in init blocks unless synthesis is set
`ifndef SYNTHESIS
  `ifndef ENABLE_INITIAL_REG_
    `define ENABLE_INITIAL_REG_
  `endif // not def ENABLE_INITIAL_REG_
`endif // not def SYNTHESIS

// Include rmemory initializers in init blocks unless synthesis is set
`ifndef SYNTHESIS
  `ifndef ENABLE_INITIAL_MEM_
    `define ENABLE_INITIAL_MEM_
  `endif // not def ENABLE_INITIAL_MEM_
`endif // not def SYNTHESIS

// Standard header to adapt well known macros for prints and assertions.

// Users can define 'PRINTF_COND' to add an extra gate to prints.
`ifndef PRINTF_COND_
  `ifdef PRINTF_COND
    `define PRINTF_COND_ (`PRINTF_COND)
  `else  // PRINTF_COND
    `define PRINTF_COND_ 1
  `endif // PRINTF_COND
`endif // not def PRINTF_COND_

// Users can define 'ASSERT_VERBOSE_COND' to add an extra gate to assert error printing.
`ifndef ASSERT_VERBOSE_COND_
  `ifdef ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ (`ASSERT_VERBOSE_COND)
  `else  // ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ 1
  `endif // ASSERT_VERBOSE_COND
`endif // not def ASSERT_VERBOSE_COND_

// Users can define 'STOP_COND' to add an extra gate to stop conditions.
`ifndef STOP_COND_
  `ifdef STOP_COND
    `define STOP_COND_ (`STOP_COND)
  `else  // STOP_COND
    `define STOP_COND_ 1
  `endif // STOP_COND
`endif // not def STOP_COND_
//`define T28_MEM

`define NUM_CLUSTER 1 //the number of cluster

`define NUM_SM 2 //the number of sm

`define NUM_SM_IN_CLUSTER `NUM_SM/`NUM_CLUSTER //the number of sm in a cluster

`define NUM_WARP 4'b1000 //the number of warp,CTA need

`define NUM_THREAD 4 //the number of thread

`define NUM_LANE `NUM_THREAD

`define NUM_BLOCK `NUM_WARP //the number of block(workgroup), not bigger than num_warp

`define NUM_WARP_IN_A_BLOCK `NUM_WARP //the number of warp in a block(workgroup)

`define NUM_FETCH 2 //a fetch refers to the number of instructions, should be power of 2

`define NUM_COLLECTORUNIT `NUM_WARP //the number of operandcollector unit in a sm

`define DEPTH_COLLECTORUNIT $clog2(`NUM_COLLECTORUNIT)

`define NUM_ISSUE 1 //the number of issue unit in a sm

`define NUM_BANK 4

`define DEPTH_BANK $clog2(`NUM_BANK)

`define NUM_VGPR 1024 //the number of vector general purpose register

`define NUM_SGPR 1024 //the number of scalar general purpose register

`define NUM_IBUFFER 2

`define NUM_SFU (`NUM_THREAD >> 2)

`define NUM_CACHE_IN_SM 2 //the number of l1cache in a sm

`define NUM_L2CACHE 1 //the number of l2cache in gpgpu

`define DEPTH_WARP $clog2(`NUM_WARP) //the depth of warp

`define DEPTH_THREAD $clog2(`NUM_THREAD) //the depth of thread

`define DEPTH_IBUFFER $clog2(`NUM_IBUFFER)

`define DEPTH_REGBANK $clog2(`NUM_VGPR/`NUM_BANK)

`define XLEN 32 //the length of data, 32-bit

`define INSTLEN 32 //the length of instructions, 32-bit

`define ADDRLEN 32 //the length of address, 32-bit

`define SIZE_IBUFFER 2

`define ICACHE_ALIGN `NUM_FETCH * 4

`define REGIDX_WIDTH 5

`define REGEXT_WIDTH 3

`define LSU_NUM_ENTRY_EACH_WARP 4 //blocking for each warp

`define LSU_NMSHRENTRY `NUM_WARP //less than num_warp

`define DCACHE_NSETS 32

`define DCACHE_NWAYS 2

`define DCACHE_BLOCKWORDS 32// Both L1$D and L1$I use this parameter

`define DCACHE_WSHR_ENTRY 4//no bigger than DCACHE_MSHRENTRY

`define DCACHE_SETIDXBITS $clog2(`DCACHE_NSETS)

`define DCACHE_WAYIDXBITS $clog2(`DCACHE_NWAYS)

`define BYTESOFWORD 4 //a word has 4 bytes

`define DCACHE_WORDOFFSETBITS $clog2(`BYTESOFWORD) 

`define DCACHE_BLOCKOFFSETBITS $clog2(`DCACHE_BLOCKWORDS) //select word in block

`define DCACHE_TAGBITS (`XLEN-(`DCACHE_SETIDXBITS+`DCACHE_BLOCKOFFSETBITS+`DCACHE_WORDOFFSETBITS))

`define DCACHE_MSHRENTRY 4//4

`define DCACHE_MSHRSUBENTRY 2

`define DCACHE_NLANES `NUM_THREAD

`define WORDLENGTH `XLEN

`define WIDBITS `DEPTH_WARP

`define BABITS (`DCACHE_TAGBITS+`DCACHE_SETIDXBITS)

`define TIWIDTH (`WIDBITS+`DCACHE_NLANES*(1+`DCACHE_BLOCKOFFSETBITS+`BYTESOFWORD))

`define DCACHE_ENTRY_DEPTH $clog2(`DCACHE_MSHRENTRY)

`define DCACHE_SUBENTRY_DEPTH $clog2(`DCACHE_MSHRSUBENTRY)

`define NUM_CACHE_DEPTH $clog2(`NUM_CACHE_IN_SM)

`define NUM_CLUSTER_DEPTH $clog2(`NUM_SM_IN_CLUSTER)

`define D_SOURCE (`NUM_CACHE_DEPTH+3+`DCACHE_ENTRY_DEPTH+`DCACHE_SETIDXBITS)

`define A_SOURCE (3+`DCACHE_ENTRY_DEPTH+`DCACHE_SETIDXBITS)

`define CLUSTER_SOURCE /*(`NUM_CLUSTER_DEPTH+3+`DCACHE_ENTRY_DEPTH+`DCACHE_SETIDXBITS)*/ (`D_SOURCE + `NUM_CLUSTER_DEPTH)

`define SHAREDMEM_DEPTH 128

`define SHAREDMEM_NWAYS 1

`define SHAREDMEM_BLOCKWORDS /*`NUM_THREAD*/ `DCACHE_BLOCKWORDS
 
`define SHAREMEM_SIZE (`SHAREDMEM_DEPTH * `SHAREDMEM_BLOCKWORDS * 4)

`define SHAREMEM_NLANES `NUM_THREAD

`define SHAREMEM_NBANKS `DCACHE_BLOCKWORDS //`SHAREMEM_NLANES //no bigger than DCACHE_BLOCKWORDS

`define SHAREDMEM_BLOCKOFFSETBITS $clog2(`SHAREDMEM_BLOCKWORDS)

`define SHAREMEM_BANKIDXBITS $clog2(`SHAREMEM_NBANKS)

`define SHAREMEM_BANKOFFSET ((`SHAREDMEM_BLOCKOFFSETBITS > `SHAREMEM_BANKIDXBITS) ? (`SHAREDMEM_BLOCKOFFSETBITS - `SHAREMEM_BANKIDXBITS) : 1 )

`define L2CACHE_NSETS 2

`define L2CACHE_NWAYS 4

`define L2CACHE_BLOCKWORDS `DCACHE_BLOCKWORDS

`define L2CACHE_WRITEBYTES 1

`define L2CACHE_MEMCYCLES 4

`define L2CACHE_PORTFACTOR 2 

`define L1CACHE_SOURCEBITS (3 + $clog2(`DCACHE_MSHRENTRY) + $clog2(`DCACHE_NSETS))

`define NUMBER_CU `NUM_SM 

`define NUMBER_RES_TABLE 1 //<NUMBER_CU

`define NUMBER_VGPR_SLOTS `NUM_VGPR

`define NUMBER_SGPR_SLOTS `NUM_SGPR

`define NUMBER_LDS_SLOTS 131072 //128kB -> 2^17

`define NUMBER_WF_SLOTS `NUM_BLOCK //the max number of wg in a cu

`define WG_ID_WIDTH 32 

`define WG_NUM_MAX `NUMBER_WF_SLOTS * `NUMBER_CU

`define WF_COUNT_MAX `NUM_WARP //the max number of wf in a cu

`define WF_COUNT_PER_WG_MAX `NUM_WARP_IN_A_BLOCK //the max number of wf in a wg

`define GDS_SIZE 1024 

`define NUMBER_ENTRIES 2 //This parameter should be a power of 2

`define WAVE_ITEM_WIDTH 4

`define MEM_ADDR_WIDTH 32

`define NUM_SCHEDULER 1 //only used for multi-cta-scheduler

`define RES_TABLE_ADDR_WIDTH (($clog2(`NUMBER_RES_TABLE) > 1) ? ($clog2(`NUMBER_RES_TABLE)) : 1)

`define CU_ID_WIDTH (($clog2(`NUMBER_CU) >= (`RES_TABLE_ADDR_WIDTH + 1)) ? ($clog2(`NUMBER_CU) + 1) : (`RES_TABLE_ADDR_WIDTH + 1))

`define VGPR_ID_WIDTH 11

`define SGPR_ID_WIDTH 11

`define LDS_ID_WIDTH $clog2(`NUMBER_LDS_SLOTS)

`define WG_SLOT_ID_WIDTH $clog2(`NUMBER_WF_SLOTS)

`define WF_COUNT_WIDTH 3

`define WF_COUNT_WIDTH_PER_WG ($clog2(`WF_COUNT_PER_WG_MAX) + 1)

`define GDS_ID_WIDTH $clog2(`GDS_SIZE)

`define ENTRY_ADDR_WIDTH $clog2(`NUMBER_ENTRIES)

`define TAG_WIDTH (`WG_SLOT_ID_WIDTH + `WF_COUNT_WIDTH_PER_WG)

`define INIT_MAX_WG_COUNT `NUMBER_WF_SLOTS

`define NUM_SCHEDULER_WIDTH $clog2(`NUM_SCHEDULER)

`define NUM_WG_X 2048 //the max number of wg in kernel

`define NUM_WG_Y 2048

`define NUM_WG_Z 2048

`define WG_SIZE_X_WIDTH $clog2(`NUM_WG_X)

`define WG_SIZE_Y_WIDTH $clog2(`NUM_WG_Y)

`define WG_SIZE_Z_WIDTH $clog2(`NUM_WG_Z)

`define LENGTH_REPLACE_TIME 10

`define TC_DIM_M 2

`define TC_DIM_N 2

`define TC_DIM_K 2

//AXI4 parameter 
`define AXI_ADDR_WIDTH   32 

`define AXI_DATA_WIDTH   64

`define AXI_ID_WIDTH     4   

`define AXI_LEN_WIDTH    8  

`define AXI_SIZE_WIDTH   3 

`define AXI_BURST_WIDTH  2

`define AXI_CACHE_WIDTH  4

`define AXI_PROT_WIDTH   3

`define AXI_QOS_WIDTH    4

`define AXI_REGION_WIDTH 4

`define AXI_USER_WIDTH   32 

`define AXI_ATOP_WIDTH   6 

`define AXI_RESP_WIDTH   2 

//AXI4LITE parameter
`define AXILITE_ADDR_WIDTH 32

`define AXILITE_DATA_WIDTH 32

`define AXILITE_PROT_WIDTH 3 

`define AXILITE_RESP_WIDTH 2 

`define AXILITE_STRB_WIDTH 4

//EXECUTION
`define NUMBER_ALU `NUM_THREAD

`define NUMBER_MUL `NUM_THREAD

`define NUMBER_FPU `NUM_THREAD

//l1dcache_define
`define TLAOP_GET          3'd4

`define TLAOP_PUTFULL      3'd0

`define TLAOP_PUTPART      3'd1

`define TLAOP_FLUSH        3'd5

`define TLAPARAM_FLUSH     3'd0

`define TLAPARAM_INV       3'd1

`define TLAOP_ARITH        3'd2

`define TLAOP_LOGIC        3'd3

`define TLAPARAM_ARITHMIN  3'd0

`define TLAPARAM_ARITHMAX  3'd1

`define TLAPARAM_ARITHMINU 3'd2

`define TLAPARAM_ARITHMAXU 3'd3

`define TLAPARAM_ARITHADD  3'd4

`define TLAPARAM_LOGICXOR  3'd0

`define TLAPARAM_LOGICOR   3'd1

`define TLAPARAM_LOGICAND  3'd2

`define TLAPARAM_LOGICSWAP 3'd3

`define TLAPARAM_LRSC      3'd1


//l2cache_define
`define L2CACHE_LEVEL 2

`define L2CACHE_BLOCKBYTES        (`L2CACHE_BLOCKWORDS * 4)

`define L2CACHE_BEATBYTES         (`L2CACHE_BLOCKWORDS * 4)

`define L2CACHE_BLOCKS            (`L2CACHE_NWAYS * `L2CACHE_NSETS )

`define L2CACHE_SIZEBYTES         (`L2CACHE_BLOCKS * `L2CACHE_BLOCKBYTES)

`define L2CACHE_BLOCKBEATS        (`L2CACHE_BLOCKBYTES / `L2CACHE_BEATBYTES) // 8/8 = 1

`define L2CACHE_NUM_WARP          `NUM_WARP

`define L2CACHE_NUM_SM            `NUM_SM

`define L2CACHE_NUM_SM_IN_CLUSTER `NUM_SM_IN_CLUSTER  //2

`define L2CACHE_NUM_CLUSTER       `NUM_CLUSTER //1

`define OP_BITS                   3

`define PARAM_BITS                3   //3+lg2(4)+lg2(32）+lg2(2) + 0+1 = 3+2+5+1 +1 =12

`define SOURCE_BITS               14

`define	URCE_S_BITS				(3 + $clog2(`DCACHE_MSHRENTRY) + $clog2(`DCACHE_NSETS) + $clog2(`L2CACHE_NUM_SM_IN_CLUSTER) + $clog2(`NUM_CACHE_IN_SM) + 1)

`define	URCE_L_BITS				(3 + $clog2(`DCACHE_MSHRENTRY) + $clog2(`DCACHE_NSETS) + $clog2(`L2CACHE_NUM_SM_IN_CLUSTER) + $clog2(`NUM_CACHE_IN_SM) + $clog2(`NUM_CLUSTER) + 1)

`define DATA_BITS                 (`L2CACHE_BEATBYTES * 8)

`define MASK_BITS                 128

`define SIZE_BITS                 ($clog2(`L2CACHE_BEATBYTES))

`define MSHRS                     ((`L2CACHE_MEMCYCLES + `L2CACHE_BLOCKBEATS - 1) / `L2CACHE_BLOCKBEATS )

`define SECONDARY                 (((`MSHRS > (`L2CACHE_MEMCYCLES - `MSHRS)) ? `MSHRS : (`L2CACHE_MEMCYCLES - `MSHRS)))

`define PUTLISTS                  `L2CACHE_MEMCYCLES

`define PUTBEATS                  ( (((2 * `L2CACHE_BLOCKBEATS) > `L2CACHE_MEMCYCLES) ? (2 * `L2CACHE_BLOCKBEATS) : `L2CACHE_MEMCYCLES))

`define RELLISTS                  2   //2*1 = 16 > 4 ? 2* 1 ：4

`define RELBEATS                  (`RELLISTS * `L2CACHE_BLOCKBEATS)

`define ADDRESS_BITS              32

`define WAY_BITS                  ($clog2(`L2CACHE_NWAYS)     )

`define SET_BITS                  ($clog2(`L2CACHE_NSETS)     )

`define OFFSET_BITS               ($clog2(`L2CACHE_BLOCKBYTES))

`define L2C_BITS                  $clog2(`NUM_L2CACHE) //`define  L2C_BITS = $clog2(`NUM_L2CACHE)

`define TAG_BITS                  (`ADDRESS_BITS - `SET_BITS - `OFFSET_BITS - `L2C_BITS)

`define PUT_BITS                  ($clog2(`PUTLISTS))

`define INNER_MASK_BITS           (`L2CACHE_BEATBYTES / `L2CACHE_WRITEBYTES)

`define OUTER_MASK_BITS           (`L2CACHE_BEATBYTES / `L2CACHE_WRITEBYTES)

//tilelink interface opcode
`define       PUTFULLDATA           3'd0         //                            => AccessAck

`define       PUTPARTIALDATA        3'd1         //                            => AccessAck

`define       ARITHMETICDATA        3'd2         //                            => AccessAckData

`define       LOGICALDATA           3'd3         //                            => AccessAckData

`define       GET                   3'd4         //                            => AccessAckData

`define       HINT                  3'd5         //                            => HintAck

`define       ACQUIREBLOCK          3'd6         //                            => Grant[Data]

`define       ACQUIREPERM           3'd7         //                            => Grant[Data]

`define       PROBE                 3'd6         //                            => ProbeAck[Data]

`define       ACCESSACK             3'd0         //                   

`define       ACCESSACKDATA         3'd1         //                   

`define       HINTACK               3'd2         //                   

`define       PROBEACK              3'd4         //               

`define       PROBEACKDATA          3'd5         //               

`define       RELEASE               3'd6         //                            => ReleaseAck

`define       RELEASEDATA           3'd7         //                            => ReleaseAck

`define       GRANT                 3'd4         //                            => GrantAck

`define       GRANTDATA             3'd5         //                            => GrantAck

`define       RELEASEACK            3'd6         //                    

`define       GRANTACK              3'd0         // 


module GPGPU_axi_adapter_top
(
  input                            clk                ,
  input                            rst_n              ,

  output                           s_axilite_awready  ,
  input                            s_axilite_awvalid  ,
  input  [`AXILITE_ADDR_WIDTH-1:0] s_axilite_awaddr   ,
  input  [`AXILITE_PROT_WIDTH-1:0] s_axilite_awprot   ,

  output                           s_axilite_wready   ,
  input                            s_axilite_wvalid   ,
  input  [`AXILITE_DATA_WIDTH-1:0] s_axilite_wdata    ,
  input  [`AXILITE_STRB_WIDTH-1:0] s_axilite_wstrb    ,

  input                            s_axilite_bready   ,
  output                           s_axilite_bvalid   ,
  output [`AXILITE_RESP_WIDTH-1:0] s_axilite_bresp    ,

  output                           s_axilite_arready  ,
  input                            s_axilite_arvalid  ,
  input  [`AXILITE_ADDR_WIDTH-1:0] s_axilite_araddr   ,
  input  [`AXILITE_PROT_WIDTH-1:0] s_axilite_arprot   ,

  input                            s_axilite_rready   ,
  output [`AXILITE_DATA_WIDTH-1:0] s_axilite_rdata    ,
  output [`AXILITE_RESP_WIDTH-1:0] s_axilite_rresp    ,
  output                           s_axilite_rvalid   , 
  input                            m_axi_awready      ,
  output                           m_axi_awvalid      ,
  output [`AXI_ID_WIDTH-1:0]       m_axi_awid         ,
  output [`AXI_ADDR_WIDTH-1:0]     m_axi_awaddr       ,
  output [`AXI_LEN_WIDTH-1:0]      m_axi_awlen        ,
  output [`AXI_SIZE_WIDTH-1:0]     m_axi_awsize       ,
  output [`AXI_BURST_WIDTH-1:0]    m_axi_awburst      ,
  output                           m_axi_awlock       ,
  output [`AXI_CACHE_WIDTH-1:0]    m_axi_awcache      ,
  output [`AXI_PROT_WIDTH-1:0]     m_axi_awprot       ,
  output [`AXI_QOS_WIDTH-1:0]      m_axi_awqos        ,
  output [`AXI_REGION_WIDTH-1:0]   m_axi_awregion     ,
  output [`AXI_ATOP_WIDTH-1:0]     m_axi_awatop       ,
  output [`AXI_USER_WIDTH-1:0]     m_axi_awuser       ,
  
 input                            m_axi_wready       ,
  output                           m_axi_wvalid       ,
  output [`AXI_DATA_WIDTH-1:0]     m_axi_wdata        ,
  output [(`AXI_DATA_WIDTH/8)-1:0] m_axi_wstrb        ,
  output                           m_axi_wlast        ,
  output [`AXI_USER_WIDTH-1:0]     m_axi_wuser        ,

  output                           m_axi_bready       ,
  input                            m_axi_bvalid       ,
  input  [`AXI_ID_WIDTH-1:0]       m_axi_bid          ,
  input  [`AXI_RESP_WIDTH-1:0]     m_axi_bresp        ,
  input  [`AXI_USER_WIDTH-1:0]     m_axi_buser        ,
  
  input                            m_axi_arready      ,
  output                           m_axi_arvalid      ,
  output [`AXI_ID_WIDTH-1:0]       m_axi_arid         ,
  output [`AXI_ADDR_WIDTH-1:0]     m_axi_araddr       ,
  output [`AXI_LEN_WIDTH-1:0]      m_axi_arlen        ,
  output [`AXI_SIZE_WIDTH-1:0]     m_axi_arsize       ,
  output [`AXI_BURST_WIDTH-1:0]    m_axi_arburst  ,
  output                           m_axi_arlock       ,
  output [`AXI_CACHE_WIDTH-1:0]    m_axi_arcache      ,
  output [`AXI_PROT_WIDTH-1:0]     m_axi_arprot       ,
  output [`AXI_QOS_WIDTH-1:0]      m_axi_arqos        ,
  output [`AXI_REGION_WIDTH-1:0]   m_axi_arregion     ,
  output [`AXI_USER_WIDTH-1:0]     m_axi_aruser       ,

  output                           m_axi_rready       ,
  input                            m_axi_rvalid       ,
  input  [`AXI_ID_WIDTH-1:0]       m_axi_rid          ,
  input  [`AXI_DATA_WIDTH-1:0]     m_axi_rdata        ,
  input  [`AXI_RESP_WIDTH-1:0]     m_axi_rresp        ,
  input                            m_axi_rlast        ,
  input  [`AXI_USER_WIDTH-1:0]     m_axi_ruser         
);

  gpgpu_axi_top u_gpgpu_axi_top(
    .clk                (clk                ),
    .rst_n              (rst_n              ),
  
    .s_axilite_awready_o(s_axilite_awready),
    .s_axilite_awvalid_i(s_axilite_awvalid),
    .s_axilite_awaddr_i (s_axilite_awaddr ),
    .s_axilite_awprot_i (s_axilite_awprot ),
 
    .s_axilite_wready_o (s_axilite_wready ),
    .s_axilite_wvalid_i (s_axilite_wvalid ),
    .s_axilite_wdata_i  (s_axilite_wdata  ),
    .s_axilite_wstrb_i  (s_axilite_wstrb  ),

    .s_axilite_bready_i (s_axilite_bready ),
    .s_axilite_bvalid_o (s_axilite_bvalid ),
    .s_axilite_bresp_o  (s_axilite_bresp  ),

    .s_axilite_arready_o(s_axilite_arready),
    .s_axilite_arvalid_i(s_axilite_arvalid),
    .s_axilite_araddr_i (s_axilite_araddr ),
    .s_axilite_arprot_i (s_axilite_arprot ),
    
    .s_axilite_rready_i (s_axilite_rready ),
    .s_axilite_rdata_o  (s_axilite_rdata  ),
    .s_axilite_rresp_o  (s_axilite_rresp  ),
    .s_axilite_rvalid_o (s_axilite_rvalid ),

    .m_axi_awready_i    (m_axi_awready    ),
    .m_axi_awvalid_o    (m_axi_awvalid    ),
    .m_axi_awid_o       (m_axi_awid       ),
    .m_axi_awaddr_o     (m_axi_awaddr     ),
    .m_axi_awlen_o      (m_axi_awlen      ),
    .m_axi_awsize_o     (m_axi_awsize     ),
    .m_axi_awburst_o    (m_axi_awburst    ),
    .m_axi_awlock_o     (m_axi_awlock     ),
    .m_axi_awcache_o    (m_axi_awcache    ),
    .m_axi_awprot_o     (m_axi_awprot     ),
    .m_axi_awqos_o      (m_axi_awqos      ),
    .m_axi_awregion_o   (m_axi_awregion   ),
    .m_axi_awatop_o     (m_axi_awatop     ),
    .m_axi_awuser_o     (m_axi_awuser     ),

    .m_axi_wready_i     (m_axi_wready     ),
    .m_axi_wvalid_o     (m_axi_wvalid     ),
    .m_axi_wdata_o      (m_axi_wdata      ),
    .m_axi_wstrb_o      (m_axi_wstrb      ),
    .m_axi_wlast_o      (m_axi_wlast      ),
    .m_axi_wuser_o      (m_axi_wuser      ),
    
    .m_axi_bready_o     (m_axi_bready     ),
    .m_axi_bvalid_i     (m_axi_bvalid     ),
    .m_axi_bid_i        (m_axi_bid        ),
    .m_axi_bresp_i      (m_axi_bresp      ),
    .m_axi_buser_i      (m_axi_buser      ),

    .m_axi_arready_i    (m_axi_arready    ),
    .m_axi_arvalid_o    (m_axi_arvalid    ),
    .m_axi_arid_o       (m_axi_arid       ),
    .m_axi_araddr_o     (m_axi_araddr     ),
    .m_axi_arlen_o      (m_axi_arlen      ),
    .m_axi_arsize_o     (m_axi_arsize     ),
    .m_axi_arburst_o    (m_axi_arburst    ),
    .m_axi_arlock_o     (m_axi_arlock     ),
    .m_axi_arcache_o    (m_axi_arcache    ),
    .m_axi_arprot_o     (m_axi_arprot     ),
    .m_axi_arqos_o      (m_axi_arqos      ),
    .m_axi_arregion_o   (m_axi_arregion   ),
    .m_axi_aruser_o     (m_axi_aruser     ),
    
    .m_axi_rready_o     (m_axi_rready     ),
    .m_axi_rvalid_i     (m_axi_rvalid     ),
    .m_axi_rid_i        (m_axi_rid        ),
    .m_axi_rdata_i      (m_axi_rdata      ),
    .m_axi_rresp_i      (m_axi_rresp      ),
    .m_axi_rlast_i      (m_axi_rlast      ),
    .m_axi_ruser_i      (m_axi_ruser      )
    );

endmodule
