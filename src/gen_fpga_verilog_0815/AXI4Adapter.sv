// Generated by CIRCT firtool-1.62.0
// Standard header to adapt well known macros for register randomization.
`ifndef RANDOMIZE
  `ifdef RANDOMIZE_MEM_INIT
    `define RANDOMIZE
  `endif // RANDOMIZE_MEM_INIT
`endif // not def RANDOMIZE
`ifndef RANDOMIZE
  `ifdef RANDOMIZE_REG_INIT
    `define RANDOMIZE
  `endif // RANDOMIZE_REG_INIT
`endif // not def RANDOMIZE

// RANDOM may be set to an expression that produces a 32-bit random unsigned value.
`ifndef RANDOM
  `define RANDOM $random
`endif // not def RANDOM

// Users can define INIT_RANDOM as general code that gets injected into the
// initializer block for modules with registers.
`ifndef INIT_RANDOM
  `define INIT_RANDOM
`endif // not def INIT_RANDOM

// If using random initialization, you can also define RANDOMIZE_DELAY to
// customize the delay used, otherwise 0.002 is used.
`ifndef RANDOMIZE_DELAY
  `define RANDOMIZE_DELAY 0.002
`endif // not def RANDOMIZE_DELAY

// Define INIT_RANDOM_PROLOG_ for use in our modules below.
`ifndef INIT_RANDOM_PROLOG_
  `ifdef RANDOMIZE
    `ifdef VERILATOR
      `define INIT_RANDOM_PROLOG_ `INIT_RANDOM
    `else  // VERILATOR
      `define INIT_RANDOM_PROLOG_ `INIT_RANDOM #`RANDOMIZE_DELAY begin end
    `endif // VERILATOR
  `else  // RANDOMIZE
    `define INIT_RANDOM_PROLOG_
  `endif // RANDOMIZE
`endif // not def INIT_RANDOM_PROLOG_

// Include register initializers in init blocks unless synthesis is set
`ifndef SYNTHESIS
  `ifndef ENABLE_INITIAL_REG_
    `define ENABLE_INITIAL_REG_
  `endif // not def ENABLE_INITIAL_REG_
`endif // not def SYNTHESIS

// Include rmemory initializers in init blocks unless synthesis is set
`ifndef SYNTHESIS
  `ifndef ENABLE_INITIAL_MEM_
    `define ENABLE_INITIAL_MEM_
  `endif // not def ENABLE_INITIAL_MEM_
`endif // not def SYNTHESIS

// Standard header to adapt well known macros for prints and assertions.

// Users can define 'PRINTF_COND' to add an extra gate to prints.
`ifndef PRINTF_COND_
  `ifdef PRINTF_COND
    `define PRINTF_COND_ (`PRINTF_COND)
  `else  // PRINTF_COND
    `define PRINTF_COND_ 1
  `endif // PRINTF_COND
`endif // not def PRINTF_COND_

// Users can define 'ASSERT_VERBOSE_COND' to add an extra gate to assert error printing.
`ifndef ASSERT_VERBOSE_COND_
  `ifdef ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ (`ASSERT_VERBOSE_COND)
  `else  // ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ 1
  `endif // ASSERT_VERBOSE_COND
`endif // not def ASSERT_VERBOSE_COND_

// Users can define 'STOP_COND' to add an extra gate to stop conditions.
`ifndef STOP_COND_
  `ifdef STOP_COND
    `define STOP_COND_ (`STOP_COND)
  `else  // STOP_COND
    `define STOP_COND_ 1
  `endif // STOP_COND
`endif // not def STOP_COND_

`timescale 1ns/1ns

module axi4_adapter_top #(
  parameter int unsigned DATA_WIDTH             = 1024 ,
  parameter int unsigned CACHELINE_BYTE_OFFSET  = 3  ,

  parameter logic        CRITICAL_WORD_FIRST    = 0  , 
  parameter int unsigned MAX_OUTSTANDING_STORES = 0  ,

  parameter int unsigned AXI_ADDR_WIDTH         = 32 ,
  parameter int unsigned AXI_DATA_WIDTH         = 64 ,
  parameter int unsigned AXI_ID_WIDTH           = 4  ,
  parameter int unsigned AXI_LEN_WIDTH          = 8  ,
  parameter int unsigned AXI_SIZE_WIDTH         = 3  ,
  parameter int unsigned AXI_BURST_WIDTH        = 2  ,
  parameter int unsigned AXI_CACHE_WIDTH        = 4  ,
  parameter int unsigned AXI_PROT_WIDTH         = 3  ,
  parameter int unsigned AXI_QOS_WIDTH          = 4  ,
  parameter int unsigned AXI_REGION_WIDTH       = 4  ,
  parameter int unsigned AXI_USER_WIDTH         = 32 ,
  parameter int unsigned AXI_ATOP_WIDTH         = 6  ,
  parameter int unsigned AXI_RESP_WIDTH         = 2   
  )
  (
  input  logic                                                           clk                  ,  
  input  logic                                                           rst_n                , 

  output logic                                                           busy_o               ,
  input  logic                                                           req_i                , // req valid
  input  logic                                                           type_i               , // req type 0-single req 1-burst req
  input  logic [3:0]                                                     amo_i                , // amo type
  output logic                                                           gnt_o                , // req ready
  input  logic [AXI_ADDR_WIDTH-1:0]                                      addr_i               ,
  input  logic                                                           we_i                 , // write or read
  input  logic [(DATA_WIDTH/AXI_DATA_WIDTH)-1:0][AXI_DATA_WIDTH-1:0]     wdata_i              ,
  input  logic [(DATA_WIDTH/AXI_DATA_WIDTH)-1:0][(AXI_DATA_WIDTH/8)-1:0] be_i                 ,
  input  logic [2:0]                                                     size_i               , // 1,2,4 or 8 bytes
  input  logic [AXI_ID_WIDTH-1:0]                                        id_i                 ,
  // read port
  output logic                                                           valid_o              ,
  output logic [(DATA_WIDTH/AXI_DATA_WIDTH)-1:0][AXI_DATA_WIDTH-1:0]     rdata_o              ,
  output logic [AXI_ID_WIDTH-1:0]                                        id_o                 ,
  // critical word - read port
  output logic [AXI_DATA_WIDTH-1:0]                                      critical_word_o      ,
  output logic                                                           critical_word_valid_o,

  input  logic                                                           m_axi_awready_i      ,
  output logic                                                           m_axi_awvalid_o      ,
  output logic [AXI_ID_WIDTH-1:0]                                        m_axi_awid_o         ,
  output logic [AXI_ADDR_WIDTH-1:0]                                      m_axi_awaddr_o       ,
  output logic [AXI_LEN_WIDTH-1:0]                                       m_axi_awlen_o        ,
  output logic [AXI_SIZE_WIDTH-1:0]                                      m_axi_awsize_o       ,
  output logic [AXI_BURST_WIDTH-1:0]                                     m_axi_awburst_o      ,
  output logic                                                           m_axi_awlock_o       ,
  output logic [AXI_CACHE_WIDTH-1:0]                                     m_axi_awcache_o      ,
  output logic [AXI_PROT_WIDTH-1:0]                                      m_axi_awprot_o       ,
  output logic [AXI_QOS_WIDTH-1:0]                                       m_axi_awqos_o        ,
  output logic [AXI_REGION_WIDTH-1:0]                                    m_axi_awregion_o     ,
  output logic [AXI_ATOP_WIDTH-1:0]                                      m_axi_awatop_o       ,
  output logic [AXI_USER_WIDTH-1:0]                                      m_axi_awuser_o       ,

  input  logic                                                           m_axi_wready_i       ,
  output logic                                                           m_axi_wvalid_o       ,
  output logic [AXI_DATA_WIDTH-1:0]                                      m_axi_wdata_o        ,
  output logic [(AXI_DATA_WIDTH/8)-1:0]                                  m_axi_wstrb_o        ,
  output logic                                                           m_axi_wlast_o        ,
  output logic [AXI_USER_WIDTH-1:0]                                      m_axi_wuser_o        ,

  output logic                                                           m_axi_bready_o       ,
  input  logic                                                           m_axi_bvalid_i       ,
  input  logic [AXI_ID_WIDTH-1:0]                                        m_axi_bid_i          ,
  input  logic [AXI_RESP_WIDTH-1:0]                                      m_axi_bresp_i        ,
  input  logic [AXI_USER_WIDTH-1:0]                                      m_axi_buser_i        ,
  
  input  logic                                                           m_axi_arready_i      ,
  output logic                                                           m_axi_arvalid_o      ,
  output logic [AXI_ID_WIDTH-1:0]                                        m_axi_arid_o         ,
  output logic [AXI_ADDR_WIDTH-1:0]                                      m_axi_araddr_o       ,
  output logic [AXI_LEN_WIDTH-1:0]                                       m_axi_arlen_o        ,
  output logic [AXI_SIZE_WIDTH-1:0]                                      m_axi_arsize_o       ,
  output logic [AXI_BURST_WIDTH-1:0]                                     m_axi_arburst_o      ,
  output logic                                                           m_axi_arlock_o       ,
  output logic [AXI_CACHE_WIDTH-1:0]                                     m_axi_arcache_o      ,
  output logic [AXI_PROT_WIDTH-1:0]                                      m_axi_arprot_o       ,
  output logic [AXI_QOS_WIDTH-1:0]                                       m_axi_arqos_o        ,
  output logic [AXI_REGION_WIDTH-1:0]                                    m_axi_arregion_o     ,
  output logic [AXI_USER_WIDTH-1:0]                                      m_axi_aruser_o       ,

  output logic                                                           m_axi_rready_o       ,
  input  logic                                                           m_axi_rvalid_i       ,
  input  logic [AXI_ID_WIDTH-1:0]                                        m_axi_rid_i          ,
  input  logic [AXI_DATA_WIDTH-1:0]                                      m_axi_rdata_i        ,
  input  logic [AXI_RESP_WIDTH-1:0]                                      m_axi_rresp_i        ,
  input  logic                                                           m_axi_rlast_i        ,
  input  logic [AXI_USER_WIDTH-1:0]                                      m_axi_ruser_i         
  );

  typedef struct packed {
    logic [AXI_ID_WIDTH-1:0]     id    ;
    logic [AXI_ADDR_WIDTH-1:0]   addr  ;
    logic [AXI_LEN_WIDTH-1:0]    len   ;
    logic [AXI_SIZE_WIDTH-1:0]   size  ;
    logic [AXI_BURST_WIDTH-1:0]  burst ;
    logic                        lock  ;
    logic [AXI_CACHE_WIDTH-1:0]  cache ;
    logic [AXI_PROT_WIDTH-1:0]   prot  ;
    logic [AXI_QOS_WIDTH-1:0]    qos   ;
    logic [AXI_REGION_WIDTH-1:0] region;
    logic [AXI_ATOP_WIDTH-1:0]   atop  ;
    logic [AXI_USER_WIDTH-1:0]   user  ;
  } axi_aw_chan_t; 

  typedef struct packed {
    logic [AXI_DATA_WIDTH-1:0]     data;
    logic [(AXI_DATA_WIDTH/8)-1:0] strb;
    logic                          last;
    logic [AXI_USER_WIDTH-1:0]     user;
  } axi_w_chan_t;

  typedef struct packed {
    logic [AXI_ID_WIDTH-1:0]   id  ;
    logic [AXI_RESP_WIDTH-1:0] resp;
    logic [AXI_USER_WIDTH-1:0] user;
  } b_chan_t;

  typedef struct packed {
    logic [AXI_ID_WIDTH-1:0]     id    ;
    logic [AXI_ADDR_WIDTH-1:0]   addr  ;
    logic [AXI_LEN_WIDTH-1:0]    len   ;
    logic [AXI_SIZE_WIDTH-1:0]   size  ;
    logic [AXI_BURST_WIDTH-1:0]  burst ;
    logic                        lock  ;
    logic [AXI_CACHE_WIDTH-1:0]  cache ;
    logic [AXI_PROT_WIDTH-1:0]   prot  ;
    logic [AXI_QOS_WIDTH-1:0]    qos   ;
    logic [AXI_REGION_WIDTH-1:0] region;
    logic [AXI_USER_WIDTH-1:0]   user  ;
  } axi_ar_chan_t; 

  typedef struct packed {
    logic [AXI_ID_WIDTH-1:0]   id  ;
    logic [AXI_DATA_WIDTH-1:0] data;
    logic [AXI_RESP_WIDTH-1:0] resp;
    logic                      last;
    logic [AXI_USER_WIDTH-1:0] user;
  } r_chan_t;

  typedef struct packed {
    axi_aw_chan_t aw      ;
    logic         aw_valid;
    axi_w_chan_t  w       ;
    logic         w_valid ;
    logic         b_ready ;
    axi_ar_chan_t ar      ;
    logic         ar_valid;
    logic         r_ready ;
  } axi_req_t;

  typedef struct packed {
    logic    aw_ready;
    logic    ar_ready;
    logic    w_ready ;
    logic    b_valid ;
    b_chan_t b       ;
    logic    r_valid ;
    r_chan_t r       ;
  } axi_rsp_t;

  axi_req_t adapter_axi_req_o,cut_slv_req_i,cut_mst_req_o;
  axi_rsp_t adapter_axi_rsp_i,cut_slv_resp_o,cut_mst_resp_i;

  // aw channel
  assign adapter_axi_rsp_i.aw_ready = cut_slv_resp_o.aw_ready;
  assign cut_slv_req_i.aw_valid = adapter_axi_req_o.aw_valid;
  assign cut_slv_req_i.aw = adapter_axi_req_o.aw;

  assign cut_mst_resp_i.aw_ready = m_axi_awready_i;
  assign m_axi_awvalid_o = cut_mst_req_o.aw_valid;
  assign m_axi_awid_o = cut_mst_req_o.aw.id;
  assign m_axi_awaddr_o = cut_mst_req_o.aw.addr;
  assign m_axi_awlen_o = cut_mst_req_o.aw.len;
  assign m_axi_awsize_o = cut_mst_req_o.aw.size;
  assign m_axi_awburst_o = cut_mst_req_o.aw.burst;
  assign m_axi_awlock_o = cut_mst_req_o.aw.lock;
  assign m_axi_awcache_o = cut_mst_req_o.aw.cache;
  assign m_axi_awprot_o = cut_mst_req_o.aw.prot;
  assign m_axi_awqos_o = cut_mst_req_o.aw.qos;
  assign m_axi_awregion_o = cut_mst_req_o.aw.region;
  assign m_axi_awatop_o = cut_mst_req_o.aw.atop;
  assign m_axi_awuser_o = cut_mst_req_o.aw.user;

  // w channel
  assign adapter_axi_rsp_i.w_ready = cut_slv_resp_o.w_ready;
  assign cut_slv_req_i.w_valid = adapter_axi_req_o.w_valid;
  assign cut_slv_req_i.w = adapter_axi_req_o.w;
  
  assign cut_mst_resp_i.w_ready = m_axi_wready_i;
  assign m_axi_wvalid_o = cut_mst_req_o.w_valid;
  assign m_axi_wdata_o = cut_mst_req_o.w.data;
  assign m_axi_wstrb_o = cut_mst_req_o.w.strb;
  assign m_axi_wlast_o = cut_mst_req_o.w.last;
  assign m_axi_wuser_o = cut_mst_req_o.w.user;

  // b channel
  assign m_axi_bready_o = cut_mst_req_o.b_ready;
  assign cut_mst_resp_i.b_valid = m_axi_bvalid_i;
  assign cut_mst_resp_i.b.id = m_axi_bid_i;
  assign cut_mst_resp_i.b.resp = m_axi_bresp_i;
  assign cut_mst_resp_i.b.user = m_axi_buser_i;

  assign cut_slv_req_i.b_ready = adapter_axi_req_o.b_ready;
  assign adapter_axi_rsp_i.b_valid = cut_slv_resp_o.b_valid;
  assign adapter_axi_rsp_i.b.id = cut_slv_resp_o.b.id;
  assign adapter_axi_rsp_i.b.resp = cut_slv_resp_o.b.resp;
  assign adapter_axi_rsp_i.b.user = cut_slv_resp_o.b.user;

  // ar channel
  assign adapter_axi_rsp_i.ar_ready = cut_slv_resp_o.ar_ready;
  assign cut_slv_req_i.ar_valid = adapter_axi_req_o.ar_valid;
  assign cut_slv_req_i.ar = adapter_axi_req_o.ar;

  assign cut_mst_resp_i.ar_ready = m_axi_arready_i;
  assign m_axi_arvalid_o = cut_mst_req_o.ar_valid;
  assign m_axi_arid_o = cut_mst_req_o.ar.id;
  assign m_axi_araddr_o = cut_mst_req_o.ar.addr;
  assign m_axi_arlen_o = cut_mst_req_o.ar.len;
  assign m_axi_arsize_o = cut_mst_req_o.ar.size;
  assign m_axi_arburst_o = cut_mst_req_o.ar.burst;
  assign m_axi_arlock_o = cut_mst_req_o.ar.lock;
  assign m_axi_arcache_o = cut_mst_req_o.ar.cache;
  assign m_axi_arprot_o = cut_mst_req_o.ar.prot;
  assign m_axi_arqos_o = cut_mst_req_o.ar.qos;
  assign m_axi_arregion_o = cut_mst_req_o.ar.region;
  assign m_axi_aruser_o = cut_mst_req_o.ar.user;

  // r channel
  assign m_axi_rready_o = cut_mst_req_o.r_ready;
  assign cut_mst_resp_i.r_valid = m_axi_rvalid_i;
  assign cut_mst_resp_i.r.id = m_axi_rid_i;
  assign cut_mst_resp_i.r.data = m_axi_rdata_i;
  assign cut_mst_resp_i.r.resp = m_axi_rresp_i;
  assign cut_mst_resp_i.r.last = m_axi_rlast_i;
  assign cut_mst_resp_i.r.user = m_axi_ruser_i;

  assign cut_slv_req_i.r_ready = adapter_axi_req_o.r_ready;
  assign adapter_axi_rsp_i.r_valid = cut_slv_resp_o.r_valid;
  assign adapter_axi_rsp_i.r.id = cut_slv_resp_o.r.id;
  assign adapter_axi_rsp_i.r.data = cut_slv_resp_o.r.data;
  assign adapter_axi_rsp_i.r.resp = cut_slv_resp_o.r.resp;
  assign adapter_axi_rsp_i.r.last = cut_slv_resp_o.r.last;
  assign adapter_axi_rsp_i.r.user = cut_slv_resp_o.r.user;

  //assign adapter_axi_rsp_i.aw_ready = m_axi_awready_i;
  //assign m_axi_awvalid_o = adapter_axi_req_o.aw_valid;
  //assign m_axi_awid_o = adapter_axi_req_o.aw.id; 
  //assign m_axi_awaddr_o = adapter_axi_req_o.aw.addr;
  //assign m_axi_awlen_o = adapter_axi_req_o.aw.len;
  //assign m_axi_awsize_o = adapter_axi_req_o.aw.size;
  //assign m_axi_awburst_o = adapter_axi_req_o.aw.burst;
  //assign m_axi_awlock_o = adapter_axi_req_o.aw.lock;
  //assign m_axi_awcache_o = adapter_axi_req_o.aw.cache;
  //assign m_axi_awprot_o = adapter_axi_req_o.aw.prot;
  //assign m_axi_awqos_o = adapter_axi_req_o.aw.qos;
  //assign m_axi_awregion_o = adapter_axi_req_o.aw.region;
  //assign m_axi_awatop_o = adapter_axi_req_o.aw.atop;
  //assign m_axi_awuser_o = adapter_axi_req_o.aw.user;

  //assign adapter_axi_rsp_i.w_ready = m_axi_wready_i;
  //assign m_axi_wvalid_o = adapter_axi_req_o.w_valid;
  //assign m_axi_wdata_o = adapter_axi_req_o.w.data;
  //assign m_axi_wstrb_o = adapter_axi_req_o.w.strb;
  //assign m_axi_wlast_o = adapter_axi_req_o.w.last;
  //assign m_axi_wuser_o = adapter_axi_req_o.w.user;

  //assign m_axi_bready_o = adapter_axi_req_o.b_ready;
  //assign adapter_axi_rsp_i.b_valid = m_axi_bvalid_i;
  //assign adapter_axi_rsp_i.b.id = m_axi_bid_i;
  //assign adapter_axi_rsp_i.b.resp = m_axi_bresp_i;
  //assign adapter_axi_rsp_i.b.user = m_axi_buser_i;
  //
  //assign adapter_axi_rsp_i.ar_ready = m_axi_arready_i;
  //assign m_axi_arvalid_o = adapter_axi_req_o.ar_valid;
  //assign m_axi_arid_o = adapter_axi_req_o.ar.id;
  //assign m_axi_araddr_o = adapter_axi_req_o.ar.addr;
  //assign m_axi_arlen_o = adapter_axi_req_o.ar.len;
  //assign m_axi_arsize_o = adapter_axi_req_o.ar.size;
  //assign m_axi_arburst_o = adapter_axi_req_o.ar.burst;
  //assign m_axi_arlock_o = adapter_axi_req_o.ar.lock;
  //assign m_axi_arcache_o = adapter_axi_req_o.ar.cache;
  //assign m_axi_arprot_o = adapter_axi_req_o.ar.prot;
  //assign m_axi_arqos_o = adapter_axi_req_o.ar.qos;
  //assign m_axi_arregion_o = adapter_axi_req_o.ar.region;
  //assign m_axi_aruser_o = adapter_axi_req_o.ar.user;

  //assign m_axi_rready_o = adapter_axi_req_o.r_ready;
  //assign adapter_axi_rsp_i.r_valid = m_axi_rvalid_i;
  //assign adapter_axi_rsp_i.r.id = m_axi_rid_i;
  //assign adapter_axi_rsp_i.r.data = m_axi_rdata_i;
  //assign adapter_axi_rsp_i.r.resp = m_axi_rresp_i;
  //assign adapter_axi_rsp_i.r.last = m_axi_rlast_i;
  //assign adapter_axi_rsp_i.r.user = m_axi_ruser_i;

  axi4_adapter #(
    .DATA_WIDTH            (DATA_WIDTH            ),
    .CRITICAL_WORD_FIRST   (CRITICAL_WORD_FIRST   ), // Critical word first enable
    .CACHELINE_BYTE_OFFSET (CACHELINE_BYTE_OFFSET ),
    .MAX_OUTSTANDING_STORES(MAX_OUTSTANDING_STORES),
    .AXI_ADDR_WIDTH        (AXI_ADDR_WIDTH        ),
    .AXI_DATA_WIDTH        (AXI_DATA_WIDTH        ),
    .AXI_ID_WIDTH          (AXI_ID_WIDTH          ),
    .AXI_LEN_WIDTH         (AXI_LEN_WIDTH         ),
    .AXI_SIZE_WIDTH        (AXI_SIZE_WIDTH        ),
    .AXI_BURST_WIDTH       (AXI_BURST_WIDTH       ),
    .AXI_CACHE_WIDTH       (AXI_CACHE_WIDTH       ),
    .AXI_PROT_WIDTH        (AXI_PROT_WIDTH        ),
    .AXI_QOS_WIDTH         (AXI_QOS_WIDTH         ),
    .AXI_REGION_WIDTH      (AXI_REGION_WIDTH      ),
    .AXI_USER_WIDTH        (AXI_USER_WIDTH        ),
    .AXI_ATOP_WIDTH        (AXI_ATOP_WIDTH        ),
    .AXI_RESP_WIDTH        (AXI_RESP_WIDTH        ),
    .axi_req_t             (axi_req_t             ),
    .axi_rsp_t             (axi_rsp_t             )
    ) axi_adapter(
    .clk_i                (clk                  ),
    .rst_ni               (rst_n                ),

    .busy_o               (busy_o               ),
    .req_i                (req_i                ),
    .type_i               (type_i               ),
    .amo_i                (amo_i                ),
    .gnt_o                (gnt_o                ),
    .addr_i               (addr_i               ),
    .we_i                 (we_i                 ),
    .wdata_i              (wdata_i              ),
    .be_i                 (be_i                 ),
    .size_i               (size_i               ),
    .id_i                 (id_i                 ),

    .valid_o              (valid_o              ),
    .rdata_o              (rdata_o              ),
    .id_o                 (id_o                 ),

    .critical_word_o      (critical_word_o      ),
    .critical_word_valid_o(critical_word_valid_o),

    .axi_req_o            (adapter_axi_req_o    ), 
    .axi_resp_i           (adapter_axi_rsp_i    ) 
    );

  axi_cut #(
    .Bypass    (1'b0         ), // bypass enable
    .aw_chan_t (axi_aw_chan_t),
    .w_chan_t  (axi_w_chan_t ),
    .b_chan_t  (b_chan_t     ),
    .ar_chan_t (axi_ar_chan_t),
    .r_chan_t  (r_chan_t     ),
    .axi_req_t (axi_req_t    ),
    .axi_resp_t(axi_rsp_t    )
    ) axi_cut(
    .clk_i (clk  ),
    .rst_ni(rst_n),
    .slv_req_i (cut_slv_req_i ),
    .slv_resp_o(cut_slv_resp_o),
    .mst_req_o (cut_mst_req_o ),
    .mst_resp_i(cut_mst_resp_i)
    );

endmodule

module axi4_adapter #(
  parameter int unsigned DATA_WIDTH             = 1024 ,
  // the AXI subsystem needs to support wrapping reads for this feature
  parameter logic        CRITICAL_WORD_FIRST    = 0  , 
  parameter int unsigned CACHELINE_BYTE_OFFSET  = 3  ,
  parameter int unsigned MAX_OUTSTANDING_STORES = 0  ,

  // AXI types
  parameter int unsigned AXI_ADDR_WIDTH         = 32 ,
  parameter int unsigned AXI_DATA_WIDTH         = 64 ,
  parameter int unsigned AXI_ID_WIDTH           = 4  ,
  parameter int unsigned AXI_LEN_WIDTH          = 8  ,
  parameter int unsigned AXI_SIZE_WIDTH         = 3  ,
  parameter int unsigned AXI_BURST_WIDTH        = 2  ,
  parameter int unsigned AXI_CACHE_WIDTH        = 4  ,
  parameter int unsigned AXI_PROT_WIDTH         = 3  ,
  parameter int unsigned AXI_QOS_WIDTH          = 4  ,
  parameter int unsigned AXI_REGION_WIDTH       = 4  ,
  parameter int unsigned AXI_USER_WIDTH         = 32 ,
  parameter int unsigned AXI_ATOP_WIDTH         = 6  ,
  parameter int unsigned AXI_RESP_WIDTH         = 2  ,

  parameter type axi_req_t = logic,
  parameter type axi_rsp_t = logic
  ) 
  (
  input  logic                                                           clk_i                ,  
  input  logic                                                           rst_ni               , 

  output logic                                                           busy_o               ,
  input  logic                                                           req_i                ,
  input  logic                                                           type_i               ,
  input  logic [3:0]                                                     amo_i                ,
  output logic                                                           gnt_o                ,
  input  logic [AXI_ADDR_WIDTH-1:0]                                      addr_i               ,
  input  logic                                                           we_i                 ,
  input  logic [(DATA_WIDTH/AXI_DATA_WIDTH)-1:0][AXI_DATA_WIDTH-1:0]     wdata_i              ,
  input  logic [(DATA_WIDTH/AXI_DATA_WIDTH)-1:0][(AXI_DATA_WIDTH/8)-1:0] be_i                 ,
  input  logic [2:0]                                                     size_i               ,
  input  logic [AXI_ID_WIDTH-1:0]                                        id_i                 ,
  // read port
  output logic                                                           valid_o              ,
  output logic [(DATA_WIDTH/AXI_DATA_WIDTH)-1:0][AXI_DATA_WIDTH-1:0]     rdata_o              ,
  output logic [AXI_ID_WIDTH-1:0]                                        id_o                 ,
  // critical word - read port
  output logic [AXI_DATA_WIDTH-1:0]                                      critical_word_o      ,
  output logic                                                           critical_word_valid_o,
  // AXI port
  output axi_req_t                                                       axi_req_o            ,
  input  axi_rsp_t                                                       axi_resp_i
  );
  
  //req type
  localparam SINGLE_REQ     = 0;
  localparam CACHE_LINE_REQ = 1;

  localparam BURST_SIZE = (DATA_WIDTH / AXI_DATA_WIDTH) - 1;

  localparam BURST_FIXED = 2'b00;
  localparam BURST_INCR  = 2'b01;
  localparam BURST_WRAP  = 2'b10;

  localparam RESP_OKAY   = 2'b00;
  localparam RESP_EXOKAY = 2'b01;
  localparam RESP_SLVERR = 2'b10;
  localparam RESP_DECERR = 2'b11;

  localparam CACHE_BUFFERABLE = 4'b0001;
  localparam CACHE_MODIFIABLE = 4'b0010;
  localparam CACHE_RD_ALLOC   = 4'b0100;
  localparam CACHE_WR_ALLOC   = 4'b1000;

  localparam ATOP_ATOMICSWAP  = 6'b110000;
  localparam ATOP_ATOMICCMP   = 6'b110001;
  localparam ATOP_NONE        = 2'b00;
  localparam ATOP_ATOMICSTORE = 2'b01;
  localparam ATOP_ATOMICLOAD  = 2'b10;
  localparam ATOP_LITTLE_END  = 1'b0;
  localparam ATOP_BIG_END     = 1'b1;
  localparam ATOP_ADD         = 3'b000;
  localparam ATOP_CLR         = 3'b001;
  localparam ATOP_EOR         = 3'b010;
  localparam ATOP_SET         = 3'b011;
  localparam ATOP_SMAX        = 3'b100;
  localparam ATOP_SMIN        = 3'b101;
  localparam ATOP_UMAX        = 3'b110;
  localparam ATOP_UMIN        = 3'b111;
  localparam ATOP_R_RESP      = 32'd5;

  localparam ADDR_INDEX = ($clog2(DATA_WIDTH/AXI_DATA_WIDTH) > 0) ? $clog2(DATA_WIDTH/AXI_DATA_WIDTH) : 1;

  localparam MAX_OUTSTANDING_AW = MAX_OUTSTANDING_STORES;

  localparam MAX_OUTSTANDING_AW_CNT_WIDTH = $clog2(MAX_OUTSTANDING_AW+1) > 0 ? $clog2(MAX_OUTSTANDING_AW+1) : 1;

  typedef logic [MAX_OUTSTANDING_AW_CNT_WIDTH-1:0] outstanding_aw_cnt_t;

  enum logic [3:0] {
    IDLE,
    WAIT_B_VALID,
    WAIT_AW_READY,
    WAIT_LAST_W_READY,
    WAIT_LAST_W_READY_AW_READY,
    WAIT_AW_READY_BURST,
    WAIT_R_VALID,
    WAIT_R_VALID_MULTIPLE,
    COMPLETE_READ,
    WAIT_AMO_R_VALID
  } state_q, state_d;

  // counter for AXI transfers
  logic [ADDR_INDEX-1:0] cnt_d, cnt_q;
  logic [(DATA_WIDTH/AXI_DATA_WIDTH)-1:0][AXI_DATA_WIDTH-1:0] cache_line_d, cache_line_q;
  // save the address for a read, as we allow for non-cacheline aligned accesses
  logic [(DATA_WIDTH/AXI_DATA_WIDTH)-1:0] addr_offset_d, addr_offset_q;
  logic [AXI_ID_WIDTH-1:0] id_d, id_q;
  logic [ADDR_INDEX-1:0] index;

  // save the atomic operation and size
  typedef enum logic [3:0] {
    AMO_NONE = 4'b0000,
    AMO_LR   = 4'b0001,
    AMO_SC   = 4'b0010,
    AMO_SWAP = 4'b0011,
    AMO_ADD  = 4'b0100,
    AMO_AND  = 4'b0101,
    AMO_OR   = 4'b0110,
    AMO_XOR  = 4'b0111,
    AMO_MAX  = 4'b1000,
    AMO_MAXU = 4'b1001,
    AMO_MIN  = 4'b1010,
    AMO_MINU = 4'b1011,
    AMO_CAS1 = 4'b1100,  // unused, not part of riscv spec, but provided in OpenPiton
    AMO_CAS2 = 4'b1101   // unused, not part of riscv spec, but provided in OpenPiton
  } amo_t;

  logic [3:0] amo_d,amo_q;

  logic [1:0] size_d, size_q;
  // outstanding write transactions counter
  outstanding_aw_cnt_t outstanding_aw_cnt_q, outstanding_aw_cnt_d;
  logic any_outstanding_aw;

  assign any_outstanding_aw = outstanding_aw_cnt_q != '0;

  // Busy if we're not idle
  assign busy_o = state_q != IDLE;

  always_comb begin : axi_fsm
    // Default assignments
    axi_req_o.aw_valid  = 1'b0;
    // Cast to AXI address width
    axi_req_o.aw.addr   = addr_i;
    axi_req_o.aw.prot   = 3'b0;
    axi_req_o.aw.region = 4'b0;
    axi_req_o.aw.len    = 8'd15;
    axi_req_o.aw.size   = size_i;  // 1, 2, 4 or 8 bytes
    axi_req_o.aw.burst  = BURST_INCR;  // Use BURST_INCR for AXI regular transaction
    axi_req_o.aw.lock   = 1'b0;
    axi_req_o.aw.cache  = CACHE_MODIFIABLE;
    axi_req_o.aw.qos    = 4'b0;
    axi_req_o.aw.id     = id_i;
    axi_req_o.aw.atop   = atop_from_amo(amo_i);
    axi_req_o.aw.user   = '0;

    axi_req_o.ar_valid  = 1'b0;
    // Cast to AXI address width
    axi_req_o.ar.addr   = addr_i;
    // in case of a single request or wrapping transfer we can simply begin at the address, if we want to request a cache-line
    // with an incremental transfer we need to output the corresponding base address of the cache line
    if (!CRITICAL_WORD_FIRST && type_i != SINGLE_REQ) begin
      axi_req_o.ar.addr[CACHELINE_BYTE_OFFSET-1:0] = '0;
    end
    axi_req_o.ar.prot = 3'b0;
    axi_req_o.ar.region = 4'b0;
    axi_req_o.ar.len = 8'd15;
    axi_req_o.ar.size = {1'b0, size_i};  // 1, 2, 4 or 8 bytes
    axi_req_o.ar.burst  = (CRITICAL_WORD_FIRST ? BURST_WRAP : BURST_INCR); // wrapping transfer in case of a critical word first strategy
    axi_req_o.ar.lock = 1'b0;
    axi_req_o.ar.cache = CACHE_MODIFIABLE;
    axi_req_o.ar.qos = 4'b0;
    axi_req_o.ar.id = id_i;
    axi_req_o.ar.user = '0;

    axi_req_o.w_valid = 1'b0;
    axi_req_o.w.data = wdata_i[0];
    axi_req_o.w.strb = be_i[0];
    axi_req_o.w.last = 1'b0;
    axi_req_o.w.user = '0;

    axi_req_o.b_ready = 1'b0;
    axi_req_o.r_ready = 1'b0;

    gnt_o = 1'b0;
    valid_o = 1'b0;
    id_o = axi_resp_i.r.id;

    critical_word_o = axi_resp_i.r.data;
    critical_word_valid_o = 1'b0;
    rdata_o = cache_line_q;

    state_d = state_q;
    cnt_d = cnt_q;
    cache_line_d = cache_line_q;
    addr_offset_d = addr_offset_q;
    id_d = id_q;
    amo_d = amo_q;
    size_d = size_q;
    index = '0;

    outstanding_aw_cnt_d = outstanding_aw_cnt_q;

    case (state_q)

      IDLE: begin
        cnt_d = '0;
        // we have an incoming request
        if (req_i) begin
          // is this a read or write?
          // write
          if (we_i) begin
            // multiple outstanding write transactions are only
            // allowed if they are guaranteed not to be reordered
            // i.e. same ID
            if (!any_outstanding_aw || ((id_i == id_q) && (amo_i == AMO_NONE))) begin
              // the data is valid
              axi_req_o.aw_valid = 1'b1;
              axi_req_o.w_valid  = 1'b1;
              // store-conditional requires exclusive access
              axi_req_o.aw.lock  = amo_i == AMO_SC;
              // its a single write
              if (type_i == SINGLE_REQ) begin
                // only a single write so the data is already the last one
                axi_req_o.w.last = 1'b1;
                // single req can be granted here
                gnt_o = axi_resp_i.aw_ready & axi_resp_i.w_ready;
                case ({
                  axi_resp_i.aw_ready, axi_resp_i.w_ready
                })
                  2'b11:   state_d = WAIT_B_VALID;
                  2'b01:   state_d = WAIT_AW_READY;
                  2'b10:   state_d = WAIT_LAST_W_READY;
                  default: state_d = IDLE;
                endcase

                if (axi_resp_i.aw_ready) begin
                  id_d   = id_i;
                  amo_d  = amo_i;
                  size_d = size_i;
                end

                // its a request for the whole cache line
              end else begin
                // bursts of AMOs unsupported
                //assert (amo_i == AMO_NONE)
                //else $fatal("Bursts of atomic operations are not supported");

                axi_req_o.aw.len = BURST_SIZE[7:0];  // number of bursts to do
                axi_req_o.w.data = wdata_i[0];
                axi_req_o.w.strb = be_i[0];

                if (axi_resp_i.w_ready) cnt_d = BURST_SIZE[ADDR_INDEX-1:0] - 1;
                else cnt_d = BURST_SIZE[ADDR_INDEX-1:0];

                case ({
                  axi_resp_i.aw_ready, axi_resp_i.w_ready
                })
                  2'b11:   state_d = WAIT_LAST_W_READY;
                  2'b01:   state_d = WAIT_LAST_W_READY_AW_READY;
                  2'b10:   state_d = WAIT_LAST_W_READY;
                  default: ;
                endcase
              end
            end
            // read
          end else begin
            // only multiple outstanding write transactions are allowed
            if (!any_outstanding_aw) begin

              axi_req_o.ar_valid = 1'b1;
              // load-reserved requires exclusive access
              axi_req_o.ar.lock = amo_i == AMO_LR;

              gnt_o = axi_resp_i.ar_ready;
              if (type_i != SINGLE_REQ) begin
                //assert (amo_i == AMO_NONE)
                //else $fatal("Bursts of atomic operations are not supported");

                axi_req_o.ar.len = BURST_SIZE[7:0];
                cnt_d = BURST_SIZE[ADDR_INDEX-1:0];
              end

              if (axi_resp_i.ar_ready) begin
                state_d = (type_i == SINGLE_REQ) ? WAIT_R_VALID : WAIT_R_VALID_MULTIPLE;
                addr_offset_d = addr_i[ADDR_INDEX-1+3:3];
              end
            end
          end
        end
      end

      // ~> from single write
      WAIT_AW_READY: begin
        axi_req_o.aw_valid = 1'b1;

        if (axi_resp_i.aw_ready) begin
          gnt_o   = 1'b1;
          state_d = WAIT_B_VALID;
          id_d    = id_i;
          amo_d   = amo_i;
          size_d  = size_i;
        end
      end

      // ~> we need to wait for an aw_ready and there is at least one outstanding write
      WAIT_LAST_W_READY_AW_READY: begin
        axi_req_o.w_valid = 1'b1;
        axi_req_o.w.last  = (cnt_q == '0);
        if (type_i == SINGLE_REQ) begin
          axi_req_o.w.data = wdata_i[0];
          axi_req_o.w.strb = be_i[0];
        end else begin
          axi_req_o.w.data = wdata_i[BURST_SIZE[ADDR_INDEX-1:0]-cnt_q];
          axi_req_o.w.strb = be_i[BURST_SIZE[ADDR_INDEX-1:0]-cnt_q];
        end
        axi_req_o.aw_valid = 1'b1;
        // we are here because we want to write a cache line
        axi_req_o.aw.len   = BURST_SIZE[7:0];
        // we got an aw_ready
        case ({
          axi_resp_i.aw_ready, axi_resp_i.w_ready
        })
          // we got an aw ready
          2'b01: begin
            // are there any outstanding transactions?
            if (cnt_q == 0) state_d = WAIT_AW_READY_BURST;
            else  // yes, so reduce the count and stay here
              cnt_d = cnt_q - 1;
          end
          2'b10:   state_d = WAIT_LAST_W_READY;
          2'b11: begin
            // we are finished
            if (cnt_q == 0) begin
              state_d = WAIT_B_VALID;
              gnt_o   = 1'b1;
              // there are outstanding transactions
            end else begin
              state_d = WAIT_LAST_W_READY;
              cnt_d   = cnt_q - 1;
            end
          end
          default: ;
        endcase

      end

      // ~> all data has already been sent, we are only waiting for the aw_ready
      WAIT_AW_READY_BURST: begin
        axi_req_o.aw_valid = 1'b1;
        axi_req_o.aw.len   = BURST_SIZE[7:0];

        if (axi_resp_i.aw_ready) begin
          state_d = WAIT_B_VALID;
          gnt_o   = 1'b1;
        end
      end

      // ~> from write, there is an outstanding write
      WAIT_LAST_W_READY: begin
        axi_req_o.w_valid = 1'b1;

        if (type_i != SINGLE_REQ) begin
          axi_req_o.w.data = wdata_i[BURST_SIZE[ADDR_INDEX-1:0]-cnt_q];
          axi_req_o.w.strb = be_i[BURST_SIZE[ADDR_INDEX-1:0]-cnt_q];
        end

        // this is the last write
        if (cnt_q == '0) begin
          axi_req_o.w.last = 1'b1;
          if (axi_resp_i.w_ready) begin
            state_d = WAIT_B_VALID;
            gnt_o   = 1'b1;
          end
        end else if (axi_resp_i.w_ready) begin
          cnt_d = cnt_q - 1;
        end
      end

      // ~> finish write transaction
      WAIT_B_VALID: begin
        id_o = axi_resp_i.b.id;

        // Write is valid
        if (axi_resp_i.b_valid && !any_outstanding_aw) begin
          axi_req_o.b_ready = 1'b1;

          // some atomics must wait for read data
          // we only accept it after accepting bvalid
          if (amo_returns_data(amo_q)) begin
            if (axi_resp_i.r_valid) begin
              // return read data if valid
              valid_o           = 1'b1;
              axi_req_o.r_ready = 1'b1;
              state_d           = IDLE;
              rdata_o           = axi_resp_i.r.data;
            end else begin
              // wait otherwise
              state_d = WAIT_AMO_R_VALID;
            end
          end else begin
            valid_o = 1'b1;
            state_d = IDLE;

            // store-conditional response
            if (amo_q == AMO_SC) begin
              if (axi_resp_i.b.resp == RESP_EXOKAY) begin
                // success -> return 0
                rdata_o = 'b0;
              end else begin
                // failure -> when request is 64-bit, return 1;
                // when request is 32-bit place a 1 in both upper
                // and lower half words. The right word will be
                // realigned/masked externally
                rdata_o = size_q == 2'b10 ? (1'b1 << 32) | 64'b1 : 64'b1;
              end
            end
          end
          // if the request was not an atomic we can possibly issue
          // other requests while waiting for the response
        end else begin
          if ((amo_q == AMO_NONE) && (outstanding_aw_cnt_q != MAX_OUTSTANDING_AW)) begin
            state_d = IDLE;
            outstanding_aw_cnt_d = outstanding_aw_cnt_q + 1;
          end
        end
      end

      // ~> some atomics wait for read data
      WAIT_AMO_R_VALID: begin
        // acknowledge data and terminate atomic
        if (axi_resp_i.r_valid) begin
          axi_req_o.r_ready = 1'b1;
          state_d           = IDLE;
          valid_o           = 1'b1;
          rdata_o           = axi_resp_i.r.data;
        end
      end

      // ~> cacheline read, single read
      WAIT_R_VALID_MULTIPLE, WAIT_R_VALID: begin
        if (CRITICAL_WORD_FIRST) index = addr_offset_q + (BURST_SIZE[ADDR_INDEX-1:0] - cnt_q);
        else index = BURST_SIZE[ADDR_INDEX-1:0] - cnt_q;

        // reads are always wrapping here
        axi_req_o.r_ready = 1'b1;
        // this is the first read a.k.a the critical word
        if (axi_resp_i.r_valid) begin
          if (CRITICAL_WORD_FIRST) begin
            // this is the first word of a cacheline read, e.g.: the word which was causing the miss
            if (state_q == WAIT_R_VALID_MULTIPLE && cnt_q == BURST_SIZE) begin
              critical_word_valid_o = 1'b1;
              critical_word_o       = axi_resp_i.r.data;
            end
          end else begin
            // check if the address offset matches - then we are getting the critical word
            if (index == addr_offset_q) begin
              critical_word_valid_o = 1'b1;
              critical_word_o       = axi_resp_i.r.data;
            end
          end

          // this is the last read
          if (axi_resp_i.r.last) begin
            id_d    = axi_resp_i.r.id;
            state_d = COMPLETE_READ;
          end

          // save the word
          if (state_q == WAIT_R_VALID_MULTIPLE) begin
            cache_line_d[index] = axi_resp_i.r.data;

          end else cache_line_d[0] = axi_resp_i.r.data;

          // Decrease the counter
          cnt_d = cnt_q - 1;
        end
      end
      // ~> read is complete
      COMPLETE_READ: begin
        valid_o = 1'b1;
        state_d = IDLE;
        id_o    = id_q;
      end

      default: state_d = IDLE;
    endcase

    // This process handles B responses when accepting
    // multiple outstanding write transactions
    if (any_outstanding_aw && axi_resp_i.b_valid) begin
      axi_req_o.b_ready = 1'b1;
      valid_o = 1'b1;
      // Right hand side contains non-registered signal as we want
      // to preserve a possible increment from the WAIT_B_VALID state
      outstanding_aw_cnt_d = outstanding_aw_cnt_d - 1;
    end
  end

  // ----------------
  // Registers
  // ----------------
  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (~rst_ni) begin
      // start in flushing state and initialize the memory
      state_q              <= IDLE;
      cnt_q                <= '0;
      cache_line_q         <= '0;
      addr_offset_q        <= '0;
      id_q                 <= '0;
      amo_q                <= AMO_NONE;
      size_q               <= '0;
      outstanding_aw_cnt_q <= '0;
    end else begin
      state_q              <= state_d;
      cnt_q                <= cnt_d;
      cache_line_q         <= cache_line_d;
      addr_offset_q        <= addr_offset_d;
      id_q                 <= id_d;
      amo_q                <= amo_d;
      size_q               <= size_d;
      outstanding_aw_cnt_q <= outstanding_aw_cnt_d;
    end
  end

  function automatic logic [AXI_ATOP_WIDTH-1:0] atop_from_amo(logic [3:0] amo);
    logic [AXI_ATOP_WIDTH-1:0] result = 6'b000000;

    unique case (amo)
      AMO_NONE: result = {ATOP_NONE, 4'b0000};
      AMO_SWAP: result = {ATOP_ATOMICSWAP};
      AMO_ADD:
      result = {ATOP_ATOMICLOAD, ATOP_LITTLE_END, ATOP_ADD};
      AMO_AND:
      result = {ATOP_ATOMICLOAD, ATOP_LITTLE_END, ATOP_CLR};
      AMO_OR:
      result = {ATOP_ATOMICLOAD, ATOP_LITTLE_END, ATOP_SET};
      AMO_XOR:
      result = {ATOP_ATOMICLOAD, ATOP_LITTLE_END, ATOP_EOR};
      AMO_MAX:
      result = {ATOP_ATOMICLOAD, ATOP_LITTLE_END, ATOP_SMAX};
      AMO_MAXU:
      result = {ATOP_ATOMICLOAD, ATOP_LITTLE_END, ATOP_UMAX};
      AMO_MIN:
      result = {ATOP_ATOMICLOAD, ATOP_LITTLE_END, ATOP_SMIN};
      AMO_MINU:
      result = {ATOP_ATOMICLOAD, ATOP_LITTLE_END, ATOP_UMIN};
      AMO_CAS1: result = {ATOP_NONE, 4'b0000};  // Unsupported
      AMO_CAS2: result = {ATOP_NONE, 4'b0000};  // Unsupported
      default: result = 6'b000000;
    endcase

    return result;
  endfunction

  function automatic logic amo_returns_data(logic [3:0] amo);
    logic [AXI_ATOP_WIDTH-1:0] atop = atop_from_amo(amo);
    logic           is_load = atop[5:4] == ATOP_ATOMICLOAD;
    logic           is_swap_or_cmp = atop[5:4] == ATOP_ATOMICSWAP[5:4];
    return is_load || is_swap_or_cmp;
  endfunction

endmodule

module axi_cut #(
  //bypass enable
  parameter bit  Bypass    = 1'b0 ,
  // AXI channel structs
  parameter type aw_chan_t = logic,
  parameter type w_chan_t  = logic,
  parameter type b_chan_t  = logic,
  parameter type ar_chan_t = logic,
  parameter type r_chan_t  = logic,
  // AXI request & response structs
  parameter type axi_req_t = logic,
  parameter type axi_resp_t= logic
  )
  (
  input logic clk_i           ,
  input logic rst_ni          ,
  //salve port
  input  axi_req_t  slv_req_i ,
  output axi_resp_t slv_resp_o,
  //master port
  output axi_req_t  mst_req_o ,
  input  axi_resp_t mst_resp_i
  );

  // a spill register for each channel
  spill_register #(
    .T     (aw_chan_t),
    .Bypass(Bypass   )
    ) i_req_aw(
    .clk_i  (clk_i              ),
    .rst_ni (rst_ni             ),
    .valid_i(slv_req_i.aw_valid ),
    .ready_o(slv_resp_o.aw_ready),
    .data_i (slv_req_i.aw       ),
    .valid_o(mst_req_o.aw_valid ),
    .ready_i(mst_resp_i.aw_ready),
    .data_o (mst_req_o.aw       )
    );

  spill_register #(
    .T     (w_chan_t ),
    .Bypass(Bypass   )
    ) i_req_w(
    .clk_i  (clk_i              ),
    .rst_ni (rst_ni             ),
    .valid_i(slv_req_i.w_valid ),
    .ready_o(slv_resp_o.w_ready),
    .data_i (slv_req_i.w       ),
    .valid_o(mst_req_o.w_valid ),
    .ready_i(mst_resp_i.w_ready),
    .data_o (mst_req_o.w       )
    );

  spill_register #(
    .T     (b_chan_t ),
    .Bypass(Bypass   )
    ) i_req_b(
    .clk_i  (clk_i              ),
    .rst_ni (rst_ni             ),
    .valid_i(mst_resp_i.b_valid ),
    .ready_o(mst_req_o.b_ready  ),
    .data_i (mst_resp_i.b       ),
    .valid_o(slv_resp_o.b_valid ),
    .ready_i(slv_req_i.b_ready  ),
    .data_o (slv_resp_o.b       )
    );

  spill_register #(
    .T     (ar_chan_t),
    .Bypass(Bypass   )
    ) i_req_ar(
    .clk_i  (clk_i              ),
    .rst_ni (rst_ni             ),
    .valid_i(slv_req_i.ar_valid ),
    .ready_o(slv_resp_o.ar_ready),
    .data_i (slv_req_i.ar       ),
    .valid_o(mst_req_o.ar_valid ),
    .ready_i(mst_resp_i.ar_ready),
    .data_o (mst_req_o.ar       )
    );

  spill_register #(
    .T     (r_chan_t ),
    .Bypass(Bypass   )
    ) i_req_r(
    .clk_i  (clk_i              ),
    .rst_ni (rst_ni             ),
    .valid_i(mst_resp_i.r_valid ),
    .ready_o(mst_req_o.r_ready  ),
    .data_i (mst_resp_i.r       ),
    .valid_o(slv_resp_o.r_valid ),
    .ready_i(slv_req_i.r_ready  ),
    .data_o (slv_resp_o.r       )
    );
   
endmodule
module spill_register #(
  parameter type T      = logic,
  parameter bit  Bypass = 1'b0   // make this spill register transparent 
  )
  (
  input  logic clk_i  ,
  input  logic rst_ni ,
  input  logic valid_i,
  output logic ready_o,
  input  T     data_i ,
  output logic valid_o,
  input  logic ready_i,
  output T     data_o  
  );

  spill_register_flushable #(
    .T     (T     ),
    .Bypass(Bypass)
    ) spill_register_flushable_i(
    .clk_i  ,
    .rst_ni ,
    .valid_i,
    .flush_i(1'b0),
    .ready_o,
    .data_i ,
    .valid_o,
    .ready_i,
    .data_o 
    );

endmodule

module spill_register_flushable #(
  parameter type T      = logic,
  parameter bit  Bypass = 1'b0   //make this spill register transparent
  )
  (
  input  logic clk_i  ,
  input  logic rst_ni ,
  input  logic valid_i,
  input  logic flush_i,
  output logic ready_o,
  input  T     data_i ,
  output logic valid_o,
  input  logic ready_i,
  output T     data_o  
  );

  if(Bypass) begin : gen_bypass
    assign valid_o = valid_i;
    assign ready_o = ready_i;
    assign data_o  = data_i ; 
  end
  else begin : gen_spill_reg
    T a_data_q;
    logic a_full_q;
    logic a_fill,a_drain;

    always_ff @(posedge clk_i or negedge rst_ni) begin : ps_a_data
      if(!rst_ni)
        a_data_q <= '0;
      else if (a_fill)
        a_data_q <= data_i;
    end

    always_ff @(posedge clk_i or negedge rst_ni) begin : ps_a_full
      if(!rst_ni)
        a_full_q <= '0;
      else if (a_fill || a_drain)
        a_full_q <= a_fill;
    end

    // The B register
    T b_data_q;
    logic b_full_q;
    logic b_fill,b_drain;

    always_ff @(posedge clk_i or negedge rst_ni) begin : ps_b_data
      if(!rst_ni)
        b_data_q <= '0;
      else if (b_fill)
        b_data_q <= a_data_q;
    end

    always_ff @(posedge clk_i or negedge rst_ni) begin : ps_b_full
      if(!rst_ni)
        b_full_q <= '0;
      else if (b_fill || b_drain)
        b_full_q <= b_fill;
    end

    // Fill the A register when the A or B register is empty. Drain the A register
    // whenever it is full and being filled, or if a flush is requested.
    assign a_fill = valid_i && ready_o && (!flush_i);
    assign a_drain = (a_full_q && !b_full_q) || flush_i;

    // Fill the B register whenever the A register is drained, but the downstream
    // circuit is not ready. Drain the B register whenever it is full and the
    // downstream circuit is ready, or if a flush if requested.
    assign b_fill = a_drain && (!ready_i) && (!flush_i);
    assign b_drain = (b_full_q && ready_i) || flush_i;

    // We can accept input as long as register B is not full.
    // Note: flush_i and valid_i must not be high at the same time,
    // otherwise an invalid handshake may occur
    assign ready_o = !a_full_q || !b_full_q;
    
    // The unit provides output as long as one of the registers is filled.
    assign valid_o = a_full_q | b_full_q;

    // We empty the spill register before the slice register.
    assign data_o = b_full_q ? b_data_q : a_data_q;
  end

endmodule