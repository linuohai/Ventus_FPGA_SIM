// Generated by CIRCT firtool-1.62.0
// Standard header to adapt well known macros for register randomization.
`ifndef RANDOMIZE
  `ifdef RANDOMIZE_MEM_INIT
    `define RANDOMIZE
  `endif // RANDOMIZE_MEM_INIT
`endif // not def RANDOMIZE
`ifndef RANDOMIZE
  `ifdef RANDOMIZE_REG_INIT
    `define RANDOMIZE
  `endif // RANDOMIZE_REG_INIT
`endif // not def RANDOMIZE

// RANDOM may be set to an expression that produces a 32-bit random unsigned value.
`ifndef RANDOM
  `define RANDOM $random
`endif // not def RANDOM

// Users can define INIT_RANDOM as general code that gets injected into the
// initializer block for modules with registers.
`ifndef INIT_RANDOM
  `define INIT_RANDOM
`endif // not def INIT_RANDOM

// If using random initialization, you can also define RANDOMIZE_DELAY to
// customize the delay used, otherwise 0.002 is used.
`ifndef RANDOMIZE_DELAY
  `define RANDOMIZE_DELAY 0.002
`endif // not def RANDOMIZE_DELAY

// Define INIT_RANDOM_PROLOG_ for use in our modules below.
`ifndef INIT_RANDOM_PROLOG_
  `ifdef RANDOMIZE
    `ifdef VERILATOR
      `define INIT_RANDOM_PROLOG_ `INIT_RANDOM
    `else  // VERILATOR
      `define INIT_RANDOM_PROLOG_ `INIT_RANDOM #`RANDOMIZE_DELAY begin end
    `endif // VERILATOR
  `else  // RANDOMIZE
    `define INIT_RANDOM_PROLOG_
  `endif // RANDOMIZE
`endif // not def INIT_RANDOM_PROLOG_

// Include register initializers in init blocks unless synthesis is set
`ifndef SYNTHESIS
  `ifndef ENABLE_INITIAL_REG_
    `define ENABLE_INITIAL_REG_
  `endif // not def ENABLE_INITIAL_REG_
`endif // not def SYNTHESIS

// Include rmemory initializers in init blocks unless synthesis is set
`ifndef SYNTHESIS
  `ifndef ENABLE_INITIAL_MEM_
    `define ENABLE_INITIAL_MEM_
  `endif // not def ENABLE_INITIAL_MEM_
`endif // not def SYNTHESIS

// Standard header to adapt well known macros for prints and assertions.

// Users can define 'PRINTF_COND' to add an extra gate to prints.
`ifndef PRINTF_COND_
  `ifdef PRINTF_COND
    `define PRINTF_COND_ (`PRINTF_COND)
  `else  // PRINTF_COND
    `define PRINTF_COND_ 1
  `endif // PRINTF_COND
`endif // not def PRINTF_COND_

// Users can define 'ASSERT_VERBOSE_COND' to add an extra gate to assert error printing.
`ifndef ASSERT_VERBOSE_COND_
  `ifdef ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ (`ASSERT_VERBOSE_COND)
  `else  // ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ 1
  `endif // ASSERT_VERBOSE_COND
`endif // not def ASSERT_VERBOSE_COND_

// Users can define 'STOP_COND' to add an extra gate to stop conditions.
`ifndef STOP_COND_
  `ifdef STOP_COND
    `define STOP_COND_ (`STOP_COND)
  `else  // STOP_COND
    `define STOP_COND_ 1
  `endif // STOP_COND
`endif // not def STOP_COND_

module rtcache_writer_1(	// ventus/src/cta/allocator.scala:61:7
  input         clock,	// ventus/src/cta/allocator.scala:61:7
                reset,	// ventus/src/cta/allocator.scala:61:7
  output        io_rt_result_ready,	// ventus/src/cta/allocator.scala:62:15
  input         io_rt_result_valid,	// ventus/src/cta/allocator.scala:62:15
  input  [10:0] io_rt_result_bits_size_0,	// ventus/src/cta/allocator.scala:62:15
                io_rt_result_bits_size_1,	// ventus/src/cta/allocator.scala:62:15
  input         io_rt_result_bits_cu_id,	// ventus/src/cta/allocator.scala:62:15
                io_alloc_en,	// ventus/src/cta/allocator.scala:62:15
                io_alloc_sel,	// ventus/src/cta/allocator.scala:62:15
                io_alloc_cuid,	// ventus/src/cta/allocator.scala:62:15
  input  [10:0] io_alloc_size,	// ventus/src/cta/allocator.scala:62:15
                io_alloc_rawdata_size_0,	// ventus/src/cta/allocator.scala:62:15
                io_alloc_rawdata_size_1,	// ventus/src/cta/allocator.scala:62:15
  output        io_rtcache_wr_en,	// ventus/src/cta/allocator.scala:62:15
                io_rtcache_wr_cuid,	// ventus/src/cta/allocator.scala:62:15
  output [10:0] io_rtcache_wr_data_size_0,	// ventus/src/cta/allocator.scala:62:15
                io_rtcache_wr_data_size_1	// ventus/src/cta/allocator.scala:62:15
);

  reg  alloc_en_r1;	// ventus/src/cta/allocator.scala:74:28
  wire alloc_wr = ~alloc_en_r1 & io_alloc_en;	// ventus/src/cta/allocator.scala:74:28, :75:{18,31}
  wire io_rt_result_ready_0 =
    ~io_alloc_en | ~alloc_wr & io_rt_result_bits_cu_id != io_alloc_cuid;	// ventus/src/cta/allocator.scala:75:31, :80:{25,38,42,52,80}
  `ifndef SYNTHESIS	// ventus/src/cta/allocator.scala:91:13
    always @(posedge clock) begin	// ventus/src/cta/allocator.scala:91:13
      if (alloc_wr & ~reset
          & (io_alloc_sel
               ? io_alloc_rawdata_size_1
               : io_alloc_rawdata_size_0) < io_alloc_size) begin	// ventus/src/cta/allocator.scala:75:31, :91:{13,50}
        if (`ASSERT_VERBOSE_COND_)	// ventus/src/cta/allocator.scala:91:13
          $error("Assertion failed\n    at allocator.scala:91 assert(io.alloc_rawdata.size(io.alloc_sel) >= io.alloc_size)\n");	// ventus/src/cta/allocator.scala:91:13
        if (`STOP_COND_)	// ventus/src/cta/allocator.scala:91:13
          $fatal;	// ventus/src/cta/allocator.scala:91:13
        if (`ASSERT_VERBOSE_COND_)	// ventus/src/cta/allocator.scala:91:13
          $error("Assertion failed\n    at allocator.scala:91 assert(io.alloc_rawdata.size(io.alloc_sel) >= io.alloc_size)\n");	// ventus/src/cta/allocator.scala:91:13
        if (`STOP_COND_)	// ventus/src/cta/allocator.scala:91:13
          $fatal;	// ventus/src/cta/allocator.scala:91:13
      end
    end // always @(posedge)
  `endif // not def SYNTHESIS
  always @(posedge clock)	// ventus/src/cta/allocator.scala:61:7
    alloc_en_r1 <= io_alloc_en;	// ventus/src/cta/allocator.scala:74:28
  `ifdef ENABLE_INITIAL_REG_	// ventus/src/cta/allocator.scala:61:7
    `ifdef FIRRTL_BEFORE_INITIAL	// ventus/src/cta/allocator.scala:61:7
      `FIRRTL_BEFORE_INITIAL	// ventus/src/cta/allocator.scala:61:7
    `endif // FIRRTL_BEFORE_INITIAL
    initial begin	// ventus/src/cta/allocator.scala:61:7
      automatic logic [31:0] _RANDOM[0:0];	// ventus/src/cta/allocator.scala:61:7
      `ifdef INIT_RANDOM_PROLOG_	// ventus/src/cta/allocator.scala:61:7
        `INIT_RANDOM_PROLOG_	// ventus/src/cta/allocator.scala:61:7
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT	// ventus/src/cta/allocator.scala:61:7
        _RANDOM[/*Zero width*/ 1'b0] = `RANDOM;	// ventus/src/cta/allocator.scala:61:7
        alloc_en_r1 = _RANDOM[/*Zero width*/ 1'b0][0];	// ventus/src/cta/allocator.scala:61:7, :74:28
      `endif // RANDOMIZE_REG_INIT
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL	// ventus/src/cta/allocator.scala:61:7
      `FIRRTL_AFTER_INITIAL	// ventus/src/cta/allocator.scala:61:7
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  assign io_rt_result_ready = io_rt_result_ready_0;	// ventus/src/cta/allocator.scala:61:7, :80:38
  assign io_rtcache_wr_en = io_rt_result_ready_0 & io_rt_result_valid | alloc_wr;	// src/main/scala/chisel3/util/Decoupled.scala:51:35, ventus/src/cta/allocator.scala:61:7, :75:31, :80:38, :86:41
  assign io_rtcache_wr_cuid = alloc_wr ? io_alloc_cuid : io_rt_result_bits_cu_id;	// ventus/src/cta/allocator.scala:61:7, :75:31, :87:18, :88:24, :93:34
  assign io_rtcache_wr_data_size_0 =
    alloc_wr
      ? io_alloc_rawdata_size_0 - (io_alloc_sel ? 11'h0 : io_alloc_size)
      : io_rt_result_bits_size_0;	// ventus/src/cta/allocator.scala:61:7, :75:31, :87:18, :90:{34,62,67}, :93:34
  assign io_rtcache_wr_data_size_1 =
    alloc_wr
      ? io_alloc_rawdata_size_1 - (io_alloc_sel ? io_alloc_size : 11'h0)
      : io_rt_result_bits_size_1;	// ventus/src/cta/allocator.scala:61:7, :75:31, :87:18, :90:{34,62,67}, :93:34
endmodule

