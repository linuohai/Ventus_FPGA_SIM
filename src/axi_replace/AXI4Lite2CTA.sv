// Generated by CIRCT firtool-1.62.0
// Standard header to adapt well known macros for register randomization.
//`define T28_MEM

`define NUM_CLUSTER 1 //the number of cluster

`define NUM_SM 2 //the number of sm

`define NUM_SM_IN_CLUSTER `NUM_SM/`NUM_CLUSTER //the number of sm in a cluster

`define NUM_WARP 4'b1000 //the number of warp,CTA need

`define NUM_THREAD 4 //the number of thread

`define NUM_LANE `NUM_THREAD

`define NUM_BLOCK `NUM_WARP //the number of block(workgroup), not bigger than num_warp

`define NUM_WARP_IN_A_BLOCK `NUM_WARP //the number of warp in a block(workgroup)

`define NUM_FETCH 2 //a fetch refers to the number of instructions, should be power of 2

`define NUM_COLLECTORUNIT `NUM_WARP //the number of operandcollector unit in a sm

`define DEPTH_COLLECTORUNIT $clog2(`NUM_COLLECTORUNIT)

`define NUM_ISSUE 1 //the number of issue unit in a sm

`define NUM_BANK 4

`define DEPTH_BANK $clog2(`NUM_BANK)

`define NUM_VGPR 1024 //the number of vector general purpose register

`define NUM_SGPR 1024 //the number of scalar general purpose register

`define NUM_IBUFFER 2

`define NUM_SFU (`NUM_THREAD >> 2)

`define NUM_CACHE_IN_SM 2 //the number of l1cache in a sm

`define NUM_L2CACHE 1 //the number of l2cache in gpgpu

`define DEPTH_WARP $clog2(`NUM_WARP) //the depth of warp

`define DEPTH_THREAD $clog2(`NUM_THREAD) //the depth of thread

`define DEPTH_IBUFFER $clog2(`NUM_IBUFFER)

`define DEPTH_REGBANK $clog2(`NUM_VGPR/`NUM_BANK)

`define XLEN 32 //the length of data, 32-bit

`define INSTLEN 32 //the length of instructions, 32-bit

`define ADDRLEN 32 //the length of address, 32-bit

`define SIZE_IBUFFER 2

`define ICACHE_ALIGN `NUM_FETCH * 4

`define REGIDX_WIDTH 5

`define REGEXT_WIDTH 3

`define LSU_NUM_ENTRY_EACH_WARP 4 //blocking for each warp

`define LSU_NMSHRENTRY `NUM_WARP //less than num_warp

`define DCACHE_NSETS 32

`define DCACHE_NWAYS 2

`define DCACHE_BLOCKWORDS 32// Both L1$D and L1$I use this parameter

`define DCACHE_WSHR_ENTRY 4//no bigger than DCACHE_MSHRENTRY

`define DCACHE_SETIDXBITS $clog2(`DCACHE_NSETS)

`define DCACHE_WAYIDXBITS $clog2(`DCACHE_NWAYS)

`define BYTESOFWORD 4 //a word has 4 bytes

`define DCACHE_WORDOFFSETBITS $clog2(`BYTESOFWORD) 

`define DCACHE_BLOCKOFFSETBITS $clog2(`DCACHE_BLOCKWORDS) //select word in block

`define DCACHE_TAGBITS (`XLEN-(`DCACHE_SETIDXBITS+`DCACHE_BLOCKOFFSETBITS+`DCACHE_WORDOFFSETBITS))

`define DCACHE_MSHRENTRY 4//4

`define DCACHE_MSHRSUBENTRY 2

`define DCACHE_NLANES `NUM_THREAD

`define WORDLENGTH `XLEN

`define WIDBITS `DEPTH_WARP

`define BABITS (`DCACHE_TAGBITS+`DCACHE_SETIDXBITS)

`define TIWIDTH (`WIDBITS+`DCACHE_NLANES*(1+`DCACHE_BLOCKOFFSETBITS+`BYTESOFWORD))

`define DCACHE_ENTRY_DEPTH $clog2(`DCACHE_MSHRENTRY)

`define DCACHE_SUBENTRY_DEPTH $clog2(`DCACHE_MSHRSUBENTRY)

`define NUM_CACHE_DEPTH $clog2(`NUM_CACHE_IN_SM)

`define NUM_CLUSTER_DEPTH $clog2(`NUM_SM_IN_CLUSTER)

`define D_SOURCE (`NUM_CACHE_DEPTH+3+`DCACHE_ENTRY_DEPTH+`DCACHE_SETIDXBITS)

`define A_SOURCE (3+`DCACHE_ENTRY_DEPTH+`DCACHE_SETIDXBITS)

`define CLUSTER_SOURCE /*(`NUM_CLUSTER_DEPTH+3+`DCACHE_ENTRY_DEPTH+`DCACHE_SETIDXBITS)*/ (`D_SOURCE + `NUM_CLUSTER_DEPTH)

`define SHAREDMEM_DEPTH 128

`define SHAREDMEM_NWAYS 1

`define SHAREDMEM_BLOCKWORDS /*`NUM_THREAD*/ `DCACHE_BLOCKWORDS
 
`define SHAREMEM_SIZE (`SHAREDMEM_DEPTH * `SHAREDMEM_BLOCKWORDS * 4)

`define SHAREMEM_NLANES `NUM_THREAD

`define SHAREMEM_NBANKS `DCACHE_BLOCKWORDS //`SHAREMEM_NLANES //no bigger than DCACHE_BLOCKWORDS

`define SHAREDMEM_BLOCKOFFSETBITS $clog2(`SHAREDMEM_BLOCKWORDS)

`define SHAREMEM_BANKIDXBITS $clog2(`SHAREMEM_NBANKS)

`define SHAREMEM_BANKOFFSET ((`SHAREDMEM_BLOCKOFFSETBITS > `SHAREMEM_BANKIDXBITS) ? (`SHAREDMEM_BLOCKOFFSETBITS - `SHAREMEM_BANKIDXBITS) : 1 )

`define L2CACHE_NSETS 2

`define L2CACHE_NWAYS 4

`define L2CACHE_BLOCKWORDS `DCACHE_BLOCKWORDS

`define L2CACHE_WRITEBYTES 1

`define L2CACHE_MEMCYCLES 4

`define L2CACHE_PORTFACTOR 2 

`define L1CACHE_SOURCEBITS (3 + $clog2(`DCACHE_MSHRENTRY) + $clog2(`DCACHE_NSETS))

`define NUMBER_CU `NUM_SM 

`define NUMBER_RES_TABLE 1 //<NUMBER_CU

`define NUMBER_VGPR_SLOTS `NUM_VGPR

`define NUMBER_SGPR_SLOTS `NUM_SGPR

`define NUMBER_LDS_SLOTS 131072 //128kB -> 2^17

`define NUMBER_WF_SLOTS `NUM_BLOCK //the max number of wg in a cu

`define WG_ID_WIDTH 32 

`define WG_NUM_MAX `NUMBER_WF_SLOTS * `NUMBER_CU

`define WF_COUNT_MAX `NUM_WARP //the max number of wf in a cu

`define WF_COUNT_PER_WG_MAX `NUM_WARP_IN_A_BLOCK //the max number of wf in a wg

`define GDS_SIZE 1024 

`define NUMBER_ENTRIES 2 //This parameter should be a power of 2

`define WAVE_ITEM_WIDTH 6

`define MEM_ADDR_WIDTH 32

`define NUM_SCHEDULER 1 //only used for multi-cta-scheduler

`define RES_TABLE_ADDR_WIDTH (($clog2(`NUMBER_RES_TABLE) > 1) ? ($clog2(`NUMBER_RES_TABLE)) : 1)

`define CU_ID_WIDTH (($clog2(`NUMBER_CU) >= (`RES_TABLE_ADDR_WIDTH + 1)) ? ($clog2(`NUMBER_CU) + 1) : (`RES_TABLE_ADDR_WIDTH + 1))

`define VGPR_ID_WIDTH 11

`define SGPR_ID_WIDTH 11

`define LDS_ID_WIDTH $clog2(`NUMBER_LDS_SLOTS)

`define WG_SLOT_ID_WIDTH $clog2(`NUMBER_WF_SLOTS)

`define WF_COUNT_WIDTH 6 //最大支持 63 个warp，64 必须加 1 

`define WF_COUNT_WIDTH_PER_WG ($clog2(`WF_COUNT_PER_WG_MAX) + 1)

`define GDS_ID_WIDTH $clog2(`GDS_SIZE)

`define ENTRY_ADDR_WIDTH $clog2(`NUMBER_ENTRIES)

`define TAG_WIDTH (`WG_SLOT_ID_WIDTH + `WF_COUNT_WIDTH_PER_WG)

`define INIT_MAX_WG_COUNT `NUMBER_WF_SLOTS

`define NUM_SCHEDULER_WIDTH $clog2(`NUM_SCHEDULER)

`define NUM_WG_X 2048 //the max number of wg in kernel

`define NUM_WG_Y 2048

`define NUM_WG_Z 2048

`define WG_SIZE_X_WIDTH $clog2(`NUM_WG_X)

`define WG_SIZE_Y_WIDTH $clog2(`NUM_WG_Y)

`define WG_SIZE_Z_WIDTH $clog2(`NUM_WG_Z)

`define LENGTH_REPLACE_TIME 10

`define TC_DIM_M 2

`define TC_DIM_N 2

`define TC_DIM_K 2

//AXI4 parameter 
`define AXI_ADDR_WIDTH   32 

`define AXI_DATA_WIDTH   64

`define AXI_ID_WIDTH     4   

`define AXI_LEN_WIDTH    8  

`define AXI_SIZE_WIDTH   3 

`define AXI_BURST_WIDTH  2

`define AXI_CACHE_WIDTH  4

`define AXI_PROT_WIDTH   3

`define AXI_QOS_WIDTH    4

`define AXI_REGION_WIDTH 4

`define AXI_USER_WIDTH   32 

`define AXI_ATOP_WIDTH   6 

`define AXI_RESP_WIDTH   2 

//AXI4LITE parameter
`define AXILITE_ADDR_WIDTH 32

`define AXILITE_DATA_WIDTH 32

`define AXILITE_PROT_WIDTH 3 

`define AXILITE_RESP_WIDTH 2 

`define AXILITE_STRB_WIDTH 4

//EXECUTION
`define NUMBER_ALU `NUM_THREAD

`define NUMBER_MUL `NUM_THREAD

`define NUMBER_FPU `NUM_THREAD

//l1dcache_define
`define TLAOP_GET          3'd4

`define TLAOP_PUTFULL      3'd0

`define TLAOP_PUTPART      3'd1

`define TLAOP_FLUSH        3'd5

`define TLAPARAM_FLUSH     3'd0

`define TLAPARAM_INV       3'd1

`define TLAOP_ARITH        3'd2

`define TLAOP_LOGIC        3'd3

`define TLAPARAM_ARITHMIN  3'd0

`define TLAPARAM_ARITHMAX  3'd1

`define TLAPARAM_ARITHMINU 3'd2

`define TLAPARAM_ARITHMAXU 3'd3

`define TLAPARAM_ARITHADD  3'd4

`define TLAPARAM_LOGICXOR  3'd0

`define TLAPARAM_LOGICOR   3'd1

`define TLAPARAM_LOGICAND  3'd2

`define TLAPARAM_LOGICSWAP 3'd3

`define TLAPARAM_LRSC      3'd1


//l2cache_define
`define L2CACHE_LEVEL 2

`define L2CACHE_BLOCKBYTES        (`L2CACHE_BLOCKWORDS * 4)

`define L2CACHE_BEATBYTES         (`L2CACHE_BLOCKWORDS * 4)

`define L2CACHE_BLOCKS            (`L2CACHE_NWAYS * `L2CACHE_NSETS )

`define L2CACHE_SIZEBYTES         (`L2CACHE_BLOCKS * `L2CACHE_BLOCKBYTES)

`define L2CACHE_BLOCKBEATS        (`L2CACHE_BLOCKBYTES / `L2CACHE_BEATBYTES) // 8/8 = 1

`define L2CACHE_NUM_WARP          `NUM_WARP

`define L2CACHE_NUM_SM            `NUM_SM

`define L2CACHE_NUM_SM_IN_CLUSTER `NUM_SM_IN_CLUSTER  //2

`define L2CACHE_NUM_CLUSTER       `NUM_CLUSTER //1

`define OP_BITS                   3

`define PARAM_BITS                3   //3+lg2(4)+lg2(32）+lg2(2) + 0+1 = 3+2+5+1 +1 =12

`define SOURCE_BITS               14

`define	URCE_S_BITS				(3 + $clog2(`DCACHE_MSHRENTRY) + $clog2(`DCACHE_NSETS) + $clog2(`L2CACHE_NUM_SM_IN_CLUSTER) + $clog2(`NUM_CACHE_IN_SM) + 1)

`define	URCE_L_BITS				(3 + $clog2(`DCACHE_MSHRENTRY) + $clog2(`DCACHE_NSETS) + $clog2(`L2CACHE_NUM_SM_IN_CLUSTER) + $clog2(`NUM_CACHE_IN_SM) + $clog2(`NUM_CLUSTER) + 1)

`define DATA_BITS                 (`L2CACHE_BEATBYTES * 8)

`define MASK_BITS                 128

`define SIZE_BITS                 ($clog2(`L2CACHE_BEATBYTES))

`define MSHRS                     ((`L2CACHE_MEMCYCLES + `L2CACHE_BLOCKBEATS - 1) / `L2CACHE_BLOCKBEATS )

`define SECONDARY                 (((`MSHRS > (`L2CACHE_MEMCYCLES - `MSHRS)) ? `MSHRS : (`L2CACHE_MEMCYCLES - `MSHRS)))

`define PUTLISTS                  `L2CACHE_MEMCYCLES

`define PUTBEATS                  ( (((2 * `L2CACHE_BLOCKBEATS) > `L2CACHE_MEMCYCLES) ? (2 * `L2CACHE_BLOCKBEATS) : `L2CACHE_MEMCYCLES))

`define RELLISTS                  2   //2*1 = 16 > 4 ? 2* 1 ：4

`define RELBEATS                  (`RELLISTS * `L2CACHE_BLOCKBEATS)

`define ADDRESS_BITS              32

`define WAY_BITS                  ($clog2(`L2CACHE_NWAYS)     )

`define SET_BITS                  ($clog2(`L2CACHE_NSETS)     )

`define OFFSET_BITS               ($clog2(`L2CACHE_BLOCKBYTES))

`define L2C_BITS                  $clog2(`NUM_L2CACHE) //`define  L2C_BITS = $clog2(`NUM_L2CACHE)

`define TAG_BITS                  (`ADDRESS_BITS - `SET_BITS - `OFFSET_BITS - `L2C_BITS)

`define PUT_BITS                  ($clog2(`PUTLISTS))

`define INNER_MASK_BITS           (`L2CACHE_BEATBYTES / `L2CACHE_WRITEBYTES)

`define OUTER_MASK_BITS           (`L2CACHE_BEATBYTES / `L2CACHE_WRITEBYTES)

//tilelink interface opcode
`define       PUTFULLDATA           3'd0         //                            => AccessAck

`define       PUTPARTIALDATA        3'd1         //                            => AccessAck

`define       ARITHMETICDATA        3'd2         //                            => AccessAckData

`define       LOGICALDATA           3'd3         //                            => AccessAckData

`define       GET                   3'd4         //                            => AccessAckData

`define       HINT                  3'd5         //                            => HintAck

`define       ACQUIREBLOCK          3'd6         //                            => Grant[Data]

`define       ACQUIREPERM           3'd7         //                            => Grant[Data]

`define       PROBE                 3'd6         //                            => ProbeAck[Data]

`define       ACCESSACK             3'd0         //                   

`define       ACCESSACKDATA         3'd1         //                   

`define       HINTACK               3'd2         //                   

`define       PROBEACK              3'd4         //               

`define       PROBEACKDATA          3'd5         //               

`define       RELEASE               3'd6         //                            => ReleaseAck

`define       RELEASEDATA           3'd7         //                            => ReleaseAck

`define       GRANT                 3'd4         //                            => GrantAck

`define       GRANTDATA             3'd5         //                            => GrantAck

`define       RELEASEACK            3'd6         //                    

`define       GRANTACK              3'd0         // 


`ifndef RANDOMIZE
  `ifdef RANDOMIZE_MEM_INIT
    `define RANDOMIZE
  `endif // RANDOMIZE_MEM_INIT
`endif // not def RANDOMIZE
`ifndef RANDOMIZE
  `ifdef RANDOMIZE_REG_INIT
    `define RANDOMIZE
  `endif // RANDOMIZE_REG_INIT
`endif // not def RANDOMIZE

// RANDOM may be set to an expression that produces a 32-bit random unsigned value.
`ifndef RANDOM
  `define RANDOM $random
`endif // not def RANDOM

// Users can define INIT_RANDOM as general code that gets injected into the
// initializer block for modules with registers.
`ifndef INIT_RANDOM
  `define INIT_RANDOM
`endif // not def INIT_RANDOM

// If using random initialization, you can also define RANDOMIZE_DELAY to
// customize the delay used, otherwise 0.002 is used.
`ifndef RANDOMIZE_DELAY
  `define RANDOMIZE_DELAY 0.002
`endif // not def RANDOMIZE_DELAY

// Define INIT_RANDOM_PROLOG_ for use in our modules below.
`ifndef INIT_RANDOM_PROLOG_
  `ifdef RANDOMIZE
    `ifdef VERILATOR
      `define INIT_RANDOM_PROLOG_ `INIT_RANDOM
    `else  // VERILATOR
      `define INIT_RANDOM_PROLOG_ `INIT_RANDOM #`RANDOMIZE_DELAY begin end
    `endif // VERILATOR
  `else  // RANDOMIZE
    `define INIT_RANDOM_PROLOG_
  `endif // RANDOMIZE
`endif // not def INIT_RANDOM_PROLOG_

// Include register initializers in init blocks unless synthesis is set
`ifndef SYNTHESIS
  `ifndef ENABLE_INITIAL_REG_
    `define ENABLE_INITIAL_REG_
  `endif // not def ENABLE_INITIAL_REG_
`endif // not def SYNTHESIS

// Include rmemory initializers in init blocks unless synthesis is set
`ifndef SYNTHESIS
  `ifndef ENABLE_INITIAL_MEM_
    `define ENABLE_INITIAL_MEM_
  `endif // not def ENABLE_INITIAL_MEM_
`endif // not def SYNTHESIS

// Standard header to adapt well known macros for prints and assertions.

// Users can define 'PRINTF_COND' to add an extra gate to prints.
`ifndef PRINTF_COND_
  `ifdef PRINTF_COND
    `define PRINTF_COND_ (`PRINTF_COND)
  `else  // PRINTF_COND
    `define PRINTF_COND_ 1
  `endif // PRINTF_COND
`endif // not def PRINTF_COND_

// Users can define 'ASSERT_VERBOSE_COND' to add an extra gate to assert error printing.
`ifndef ASSERT_VERBOSE_COND_
  `ifdef ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ (`ASSERT_VERBOSE_COND)
  `else  // ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ 1
  `endif // ASSERT_VERBOSE_COND
`endif // not def ASSERT_VERBOSE_COND_

// Users can define 'STOP_COND' to add an extra gate to stop conditions.
`ifndef STOP_COND_
  `ifdef STOP_COND
    `define STOP_COND_ (`STOP_COND)
  `else  // STOP_COND
    `define STOP_COND_ 1
  `endif // STOP_COND
`endif // not def STOP_COND_

`timescale 1ns/1ns


module axi4lite_2_cta #(
  parameter AXILITE_ADDR_WIDTH   = 32,
  parameter AXILITE_DATA_WIDTH   = 32,
  parameter AXILITE_PROT_WIDTH   = 3 ,
  parameter AXILITE_RESP_WIDTH   = 2 ,  
  parameter AXILITE_STRB_WIDTH   = 4  
  )
(
  input                           clk                                             ,
  input                           rst_n                                           ,

  //cta to axi
  output                          host_rsp_ready_o                                ,
  input                           host_rsp_valid_i                                ,
  input  [`WG_ID_WIDTH-1:0]       host_rsp_inflight_wg_buffer_host_wf_done_wg_id_i,
  //axi to cta
  input                           host_req_ready_i                                ,
  output                          host_req_valid_o                                ,
  output [`WG_ID_WIDTH-1:0]       host_req_wg_id_o                                ,
  output [`WF_COUNT_WIDTH-1:0]    host_req_num_wf_o                               ,
  output [`WAVE_ITEM_WIDTH-1:0]   host_req_wf_size_o                              ,
  output [`MEM_ADDR_WIDTH-1:0]    host_req_start_pc_o                             ,
  output [`WG_SIZE_X_WIDTH*3-1:0] host_req_kernel_size_3d_o                       ,
  output [`MEM_ADDR_WIDTH-1:0]    host_req_pds_baseaddr_o                         ,
  output [`MEM_ADDR_WIDTH-1:0]    host_req_csr_knl_o                              ,
  output [`VGPR_ID_WIDTH:0]       host_req_vgpr_size_total_o                      ,
  output [`SGPR_ID_WIDTH:0]       host_req_sgpr_size_total_o                      ,
  output [`LDS_ID_WIDTH:0]        host_req_lds_size_total_o                       ,
  // output [`GDS_ID_WIDTH:0]        host_req_gds_size_total_o                       ,
  output [`VGPR_ID_WIDTH:0]       host_req_vgpr_size_per_wf_o                     ,
  output [`SGPR_ID_WIDTH:0]       host_req_sgpr_size_per_wf_o                     ,
  output [31:0]                   host_req_pds_size_per_wf_o,
  output [`MEM_ADDR_WIDTH-1:0]    host_req_gds_baseaddr_o                         ,
  
  output                          s_axilite_awready_o                             ,
  input                           s_axilite_awvalid_i                             ,
  input  [AXILITE_ADDR_WIDTH-1:0] s_axilite_awaddr_i                              ,
  input  [AXILITE_PROT_WIDTH-1:0] s_axilite_awprot_i                              ,
  
  output                          s_axilite_wready_o                              ,
  input                           s_axilite_wvalid_i                              ,
  input  [AXILITE_DATA_WIDTH-1:0] s_axilite_wdata_i                               ,
  input  [AXILITE_STRB_WIDTH-1:0] s_axilite_wstrb_i                               ,

  input                           s_axilite_bready_i                              ,
  output                          s_axilite_bvalid_o                              ,
  output [AXILITE_RESP_WIDTH-1:0] s_axilite_bresp_o                               ,
  
  output                          s_axilite_arready_o                             ,
  input                           s_axilite_arvalid_i                             ,
  input  [AXILITE_ADDR_WIDTH-1:0] s_axilite_araddr_i                              ,
  input  [AXILITE_PROT_WIDTH-1:0] s_axilite_arprot_i                              ,

  input                           s_axilite_rready_i                              ,
  output [AXILITE_DATA_WIDTH-1:0] s_axilite_rdata_o                               ,
  output [AXILITE_RESP_WIDTH-1:0] s_axilite_rresp_o                               ,
  output                          s_axilite_rvalid_o                               
  );
  
  localparam NUM_REG = 19;

  localparam IDLE      = 5'b00000,
             READADDR  = 5'b00001,
             READDATA  = 5'b00010,
             WRITEADDR = 5'b00100,
             WRITEDATA = 5'b01000,
             WRITERESP = 5'b10000;

  localparam OUT_IDLE  = 1'b0,
             OUT_OUTPUT= 1'b1;
             
   reg [NUM_REG*AXILITE_DATA_WIDTH-1:0] data_buf;
  reg [AXILITE_DATA_WIDTH-1:0] data_out;

  reg awready,wready,bvalid,arready,rvalid;

  reg [AXILITE_ADDR_WIDTH-1:0] addr;
  reg write;
  wire [AXILITE_DATA_WIDTH-1:0] rdata;
  reg [AXILITE_DATA_WIDTH-1:0] rdata_reg;

  reg s_axilite_rready_r,rvalid_r;
  
  reg [4:0] state;
  reg out_state;

  always @(posedge clk or negedge rst_n) begin
    if(!rst_n) begin
      out_state <= OUT_IDLE;
    end 
    else begin
      case(out_state)
        OUT_IDLE   : if(data_buf[0]) begin
                       out_state <= OUT_OUTPUT;
                     end 
                     else begin
                       out_state <= out_state;
                     end 
        OUT_OUTPUT : if(host_req_valid_o && host_req_ready_i) begin
                       out_state <= OUT_IDLE;
                     end 
                     else begin
                       out_state <= out_state;
                     end 
        default    : out_state <= out_state; 
      endcase
    end 
  end
  
  always @(posedge clk or negedge rst_n) begin
    if(!rst_n) begin
      state <= IDLE;
      arready <= 1'b0;
      rvalid <= 1'b0;
      awready <= 1'b0;
      write <= 1'b0;
      wready <= 1'b0;
      bvalid <= 1'b0;
      addr <= 'b0;
      data_out <= 'b0;
    end
    else begin
      case(state)
        IDLE      : begin
                      rvalid <= 1'b0;
                      bvalid <= 1'b0;
                      write <= 1'b0;
                      if(s_axilite_awvalid_i && (out_state == OUT_IDLE)) begin
                        state <= WRITEADDR;
                      end
                      else if(s_axilite_arvalid_i) begin
                        state <= READADDR;
                      end 
                      else begin
                        state <= IDLE;
                      end 
                    end
        READADDR  : begin
                      if(s_axilite_arvalid_i && s_axilite_arready_o/*arready*/) begin
                        state <= READDATA;
                        arready <= 1'b0;
                        addr <= s_axilite_araddr_i[AXILITE_ADDR_WIDTH-1:2];
                      end
                       else begin
                        state <= READADDR;
                        arready <= 1'b1;
                        addr <= addr;
                      end 
                    end
                 READDATA  : begin
                      if(s_axilite_rready_i && s_axilite_rvalid_o) begin
                        state <= IDLE;
                        rvalid <= 1'b0;
                      end 
                      else begin
                        state <= READDATA;
                        rvalid <= 1'b1;
                      end 
                    end
                    WRITEADDR : begin
                      if(s_axilite_awvalid_i && s_axilite_awready_o/*awready*/) begin
                        state <= WRITEDATA;
                        awready <= 1'b0;
                        addr <= s_axilite_awaddr_i[AXILITE_ADDR_WIDTH-1:2];
                      end
                      else begin
                        state <= WRITEADDR;
                        awready <= 1'b1;
                        addr <= addr;
                      end 
                    end
                   WRITEDATA : begin
                      if(s_axilite_wvalid_i && s_axilite_wready_o/*wready*/) begin
                        state <= WRITERESP;
                        data_out <= s_axilite_wdata_i;
                        write <= 1'b1;
                        wready <= 1'b0;
                      end
                      else begin
                        state <= WRITEDATA;
                        data_out <= data_out;
                        write <= write;
                        wready <= 1'b1;
                      end 
                    end
                         WRITERESP : begin
                      if(s_axilite_bready_i && s_axilite_bvalid_o/*bvalid*/) begin
                        state <= IDLE;
                        write <= 1'b0;
                        bvalid <= 1'b0;
                      end 
                      else begin
                        state <= WRITERESP;
                        write <= 1'b0;
                        bvalid <= 1'b1;
                      end
                    end
                           default   : begin
                      state <= IDLE;
                    end 
      endcase
    end 
  end 
   always @(posedge clk or negedge rst_n) begin
    if(!rst_n) begin
      s_axilite_rready_r <= 1'b0;
      rvalid_r <= 1'b0;
    end 
    else begin
      s_axilite_rready_r <= s_axilite_rready_i;
      rvalid_r <= rvalid;
    end 
  end
     assign host_rsp_ready_o = host_rsp_valid_i && (data_buf[17*AXILITE_DATA_WIDTH]==1'd0);

  always @(posedge clk or negedge rst_n) begin
    if(!rst_n) begin
      rdata_reg <= 'h0;
    end 
    else begin
      rdata_reg <= rdata;
    end 
  end
   
     assign rdata = (s_axilite_rready_r || (!rvalid_r)) ? data_buf[((addr+1)*AXILITE_DATA_WIDTH-1)-:AXILITE_DATA_WIDTH] : rdata_reg;

  assign s_axilite_rdata_o = rdata;
  assign s_axilite_awready_o = awready;
  assign s_axilite_wready_o = wready;
  assign s_axilite_bvalid_o = bvalid;
  assign s_axilite_bresp_o = 2'b0;
  assign s_axilite_arready_o = arready;
  assign s_axilite_rvalid_o = rvalid;
  assign s_axilite_rresp_o = 2'b0;
  
  assign host_req_valid_o = data_buf[0] && (out_state == OUT_OUTPUT);
  assign host_req_wg_id_o = data_buf[(1+1)*AXILITE_DATA_WIDTH-1 -: AXILITE_DATA_WIDTH];           
  assign host_req_num_wf_o = data_buf[(2+1)*AXILITE_DATA_WIDTH-1 -: AXILITE_DATA_WIDTH];         
  assign host_req_wf_size_o = data_buf[(3+1)*AXILITE_DATA_WIDTH-1 -: AXILITE_DATA_WIDTH];        
  assign host_req_start_pc_o = data_buf[(4+1)*AXILITE_DATA_WIDTH-1 -: AXILITE_DATA_WIDTH];       
  assign host_req_vgpr_size_total_o = data_buf[(5+1)*AXILITE_DATA_WIDTH-1 -: AXILITE_DATA_WIDTH]; 
  assign host_req_sgpr_size_total_o = data_buf[(6+1)*AXILITE_DATA_WIDTH-1 -: AXILITE_DATA_WIDTH];   
  assign host_req_lds_size_total_o = data_buf[(7+1)*AXILITE_DATA_WIDTH-1 -: AXILITE_DATA_WIDTH];        
  // assign host_req_gds_size_total_o = 'b0;
    assign host_req_vgpr_size_per_wf_o = data_buf[(8+1)*AXILITE_DATA_WIDTH-1 -: AXILITE_DATA_WIDTH];
  assign host_req_sgpr_size_per_wf_o = data_buf[(9+1)*AXILITE_DATA_WIDTH-1 -: AXILITE_DATA_WIDTH]; 
  assign host_req_gds_baseaddr_o = data_buf[(10+1)*AXILITE_DATA_WIDTH-1 -: AXILITE_DATA_WIDTH]; 
  assign host_req_pds_baseaddr_o = data_buf[(11+1)*AXILITE_DATA_WIDTH-1 -: AXILITE_DATA_WIDTH];
  assign host_req_csr_knl_o = data_buf[(12+1)*AXILITE_DATA_WIDTH-1 -: AXILITE_DATA_WIDTH]; 
   assign host_req_kernel_size_3d_o[(`WG_SIZE_X_WIDTH*(0+1)-1)-:`WG_SIZE_X_WIDTH] = data_buf[(13+1)*AXILITE_DATA_WIDTH-1 -: AXILITE_DATA_WIDTH];   
  assign host_req_kernel_size_3d_o[(`WG_SIZE_X_WIDTH*(1+1)-1)-:`WG_SIZE_X_WIDTH] = data_buf[(14+1)*AXILITE_DATA_WIDTH-1 -: AXILITE_DATA_WIDTH];   
  assign host_req_kernel_size_3d_o[(`WG_SIZE_X_WIDTH*(2+1)-1)-:`WG_SIZE_X_WIDTH] = data_buf[(15+1)*AXILITE_DATA_WIDTH-1 -: AXILITE_DATA_WIDTH];   
  assign host_req_pds_size_per_wf_o[31:0] = data_buf[(18+1)*AXILITE_DATA_WIDTH-1 -: AXILITE_DATA_WIDTH];
 always @(posedge clk or negedge rst_n) begin
    if(!rst_n) begin
      data_buf <= 'b0;
    end 
    else if(host_rsp_valid_i && (!data_buf[17*AXILITE_DATA_WIDTH])) begin
      data_buf[(17+1)*AXILITE_DATA_WIDTH-1 -: AXILITE_DATA_WIDTH] <= 'b1;
      data_buf[(16+1)*AXILITE_DATA_WIDTH-1 -: AXILITE_DATA_WIDTH] <= host_rsp_inflight_wg_buffer_host_wf_done_wg_id_i;
    end
    else if((state==READDATA)&&(addr==17)&&data_buf[17*AXILITE_DATA_WIDTH]&&(rvalid==1'd1)) begin
      data_buf[(17+1)*AXILITE_DATA_WIDTH-1 -: AXILITE_DATA_WIDTH] <= 'b0;
    end 
    else if((out_state == OUT_OUTPUT) && host_req_ready_i && host_req_valid_o) begin
      data_buf[(0+1)*AXILITE_DATA_WIDTH-1 -: AXILITE_DATA_WIDTH] <= 'b0;
    end 
   else if(write) begin
      data_buf[(addr+1)*AXILITE_DATA_WIDTH-1 -: AXILITE_DATA_WIDTH] <= data_out;
    end 
    else begin
      data_buf <= data_buf;
    end 
  end 
endmodule